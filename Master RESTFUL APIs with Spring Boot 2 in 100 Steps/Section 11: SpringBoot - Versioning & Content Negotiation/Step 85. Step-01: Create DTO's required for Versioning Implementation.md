### Step 85. Step-01: Create DTO's required for Versioning Implementation.md
Welcome back.  In this lecture, we are going to create a new big brand for our versioning module and then we are going  to create the divisions and they are just filled in our user entity.  These we are going to do to move on with our internal implementation for versioning with all the four  types which we have discussed in our introductory section.  So let's go back to the code and then review the steps which we are going to perform.  So if you see here, we are going to create new good brand.  So I'm going to come up with this and then put this ready.  And the next is we are going to go to the user entity and then add a new field address.  So once we added whatever we have defined in our data that Ezekial, which is nothing but our pre populated  data, it is going to tretter.  So we'll also add some data for address column in the data that Ezekial.  So that completes our entity layer changes.  So then we'll move on to our data layer and will create details.  So one is user data will be one and the other is user V2.  In the user it will be one.  We will ensure that whatever is currently present before adding address feel.  So we will try to define all those things except address and user data.  We will also add the address field.  If you see here, we are going to do this with our GPA implementation and also the -- to database.  So it says that it looks like 100 percent real type of implementation where then we want to handle these  things from versioning perspective, how we want to handle our controller layer or our service layer  with our videos and then all these things we are going to look into now.  So let's go back to the idea, you know.  Right.  So if you see let me go to the get perspective.  And if you see here.  The previous comment, which we have done is with the maps, that means like the previous section which  we completed is 10 to Springboot detours, maps, and it is also merged with our remote muster and  our local master, which means from our local master, we can create a new branch.  OK, and then I'll give the names 11 01 Springboot Learning.  So the reason I have two 11 zero one one zero two, we are going to look into Springboot content negotiation.  So we are going to have two modules in the lemon section.  One is watching and the other is content negotiation.  So far, zero one we are giving versioning.  So let me click on finish.  So we have checked out now with our 11 zero one Springboot LESSONING.  So let's go back to our idea.  So our first challenge is to go to the user entity and then implement the new address, fill in that.  So I'm going to include this section here, OK?  And then I'll open my user entity.  Right.  So let me make it bigger.  So I'll go down.  And here I'm going to add a new field named Public String Address.  So I'm just giving it as a string for now.  But if we want, we can even create a model for that and then define like city and then street and then  country, everything we can define.  OK, but for now, to make our implementation easy and also to ensure that we, our core focuses on  versioning.  So in short, I'm just giving the string here, OK, and I can see column.  Right.  And the name is equal to I'll address OK and will go down and will regenerate our fields.  Constructor with that.  OK, we can even write it but it's good that if we generate.  Constructed using fields, and we have the address listed.  Now let me generate it, OK, so it had generated here, so let me copy that card and then pasted here.  So now we have generated fields constructor.  Let's also generate the getters and setters.  OK, so I will generate the getters setters.  So generate getters and setters for our address will select all it selected let me generated light.  So we also generated a two string earlier.  OK, so the two string mainly is for our if we enable any logging in our controller, our service layer  and if we want to log something related to this user object or user being so we can this to string is  there, then the things will be logged effectively.  So that's the reason we are generating this two string.  So let me read into it with our new data.  OK, generate two string generator.  So ideally we didn't enable logging so far, but on some time later when we are working on the logging  module, effectively, we are going to look into it.  So now if you see if I start the.  Tomcat, it is going to fail.  OK, why?  Because we don't have the address feel right, so address the data we don't have so obviously it is  going to fail.  Column count does not match Eskil statement.  We can see it very clearly.  So let's go to our DataDot skill in our sauce main resources.  So here, let me say open with Backstreet's.  Right.  So address will come as the second field based on the.  Order.  Right, alphabetical order.  So ideally, we need to define our queries with the user and then hear everything, the detail, column  names come up and then in that order, we need to fill the data here, for example, like a user I.D.  and then address in the same order.  We need to fill the data here, but that it looks bigger.  So we just took the shortest path, OK?  So but only one thing we need to ensure is we if that field comes here, are not we need to cross-check  in our history database.  OK, so like that.  So we'll have some minor issues with this.  But fine.  OK.  So here it is.  It's only a in-memory database.  Right.  So here I am going to say I'm just going to use that restring, OK.  So in the same way.  So I'll also give you here New Jersey.  Right, and here I will say.  California.  OK, so we added.  Three fields here, OK, means like for the three records, we are there, the address.  So let me save this.  OK, now it is safe, let me start this back, OK, Ranna'sSpringboot dletop.  OK, this started, so let me go back to our house to console.  And then let me connect to that and then click on users, so let's start from user one selector so you  can see user right here and then we got the address and then address that also populated here.  So as I said earlier, after the user area address got populated, accordingly, we have used to date,  but ideally we can write our own insert statement when you are writing.  You can write, as I said earlier.  OK, so it is nothing but insert user insert in the user and then we can define all of our column names  here.  And then in the same order, whatever.  We have defined the column names here, we can enter the data here.  OK, so let me save this back.  OK, so no changes.  So this looks good.  So this completes our both entity changes and other data security changes.  So our next step in this system in this respect to model is in this respect letter is to focus on creating  our two.  Dee Dee was OK, so data transfer objects, nothing but user data will we want and then use the data  we do.  So if we go to over data or section, we have user.md and then user MSJ do so in a previous section.  When we are working on model mapper and then map struct, we ensure that we have created these things,  which is nothing but a means nothing but model mapper and A is nothing but map struct.  So for our versioning section will create user data V1 and then use a veto.  Right.  So I'll see user little Vivaan.  Right.  And then let me finish.  So here we need to define all other variables.  OK, so all the fields we can see.  Right.  So let me go to user.  OK, and then let me capital orders, OK, so except address, we are going to have everything in this,  right?  So let me go to you.  That will be one.  And let me remove all these things, whatever we have extra.  Right.  So let me come here.  OK.  So just a second.  It is over almost, OK?  So we have all our.  Friends defined here use a lady username, first name, last name, email and then assistant and then  order.  OK, so let me source and then generate our.  Getters and setters for all these things.  OK, so generate and will also generate for the GOP, so no argument constructor is needed to make GOP  happy.  So I'll see constructor.  OK, then let me remove this and false constructor will generate it and then put it, and if required,  when we are doing logging or anything, it will be useful for us.  Right.  So I'll see.  OK, so gender that feels constructed also, so we have now everything ready here.  So this completes our user, DTL, V1, right.  So let me save this and minimize and I'll go here and create our user data.  We do.  Right.  So next class is.  You said that you veto and let me click on finish.  So now we are going to create you that it will veto.  So what we have so far, we have the following vote.  So let me copy and paste best.  We have all the variables in the date of a veto.  We are going to have one thing extra here.  It is nothing but our address feel right.  So let me get this and copy it in our user.  Veto.  Right.  So now let's generate all our getters and setters and everything, OK, so gendered constructor from  Superclass.  OK, so that's done.  So let me bring it down.  Yeah.  Let me generate our constructor using feels generate.  And finally.  Generate our data, set us selectable and generate.  So we completed creating our user data veto, so this completes our section, right, so we need to  add new full name address, addressing our user entity, update the data school.  And in the data, literally, we need to create user data even and then user data we do.  So we have completed these things in the next lecture will move on with implementing Urara versioning.    .  Thank you.    
