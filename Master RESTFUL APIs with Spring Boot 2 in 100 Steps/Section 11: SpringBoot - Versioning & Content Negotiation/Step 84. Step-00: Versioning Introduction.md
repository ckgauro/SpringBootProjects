### Step 84. Step-00: Versioning Introduction.md
Welcome back.  In this section, we are going to understand and implement a pill rationing using Springboard.  So if you see here, it is primarily categorized into four of us.  We can implement Springboard.  So once is the solution and the other is the request parameter rationing and the other is custom header  rationing.  The last one is we type are mine type are acceptable rationing.  So to start with and start with and understand what you are rationing.  So if you see here you run over something is nothing.  But we are going to provide you what is the version of the EPA if we are implementing multiple versions  of our EPA.  So we are just going to provide its rationing now where you are.  So if you see here we have the one that we're watching rationale for the EPA and B 2.0 version of our  AP implementation.  We are going to add additional address field in our entity and then we are going to retrieve that using  V 2.0, which means in our in response, we are going to see addressing those extra.  And we did meet with the Russian and in Russian, it is going to be, as is so far, whatever we have  to build it.  So we're going to do that again.  It is going to be absolutely real time.  It's not.  We just.  Beans and then static beans and then creating some variables.  It's not like that, okay, so we're going to use standard GPA and implement it.  So as we have already created the entity.  So now we need to ensure that to support both views.  One is B 1.0 and and B 2.0.  In very previous lectures, we have already discussed about three major things.  OK, so one is the model mapper for the details.  The other is map script and also Jason.  So we have already implemented those things in our previous sections.  So what we will do is by using that knowledge, we will try to implement and then showcase our V 1.0  and then V 2.0, the different fields.  And so not using the model number so that we like a single entity, having multiple fields like newly  implemented fields will be available in 2.0 using model mapper and whatever we have created for V 2.0.  So movement from university, that is the request parameter versioning indicus parameter rationing.  If you see we're going to pass the parameters of the model so that parameter.  So if you see here, Russian is equal to one, so they can also say the parameters.  So the other one is watching is called as usual, the same user data as what we have created is auditable  what we want and then veto accordingly.  We are going to leverage for implementing the request parameter worsening too.  So the next one, Mouzon is like custom header versioning.  So so far we have seen UI and also the WIKUS parameter.  So the next is to implement the API versioning using custom header.  So we are going to implement it in such a way that whenever we send a header name as a Russian with  value as one, then the JSON response will be whatever is related to Russian one.  And if you send, then whatever is related to will be displayed.  So that's about the version we we're going to implement.  So the next is media type.  We also call it as mime type or even the acceptable versioning.  So in this we are going to send accept header.  So and when they accept that, we are going to define in our respective method.  So if you see here, this is the accepted that, OK, so this is the standard format to define it.  OK, and if you go to Disney dot org, we have the letter standards to define it and then follow a lot  of standards for implementing Meatpaper mind type headers.  OK, but for now we can take this as a reference and then we can implement it.  So this is the V1, but our python difference is that we need to fetch the V1 API details.  So the same be happy for me to fetch as the beta version of the details.  So moving on to the implementation steps.  So what we are going to do is as usual, we are going to create a new branch for our Entropia learning  module and we will create the prerequisite things required for us.  So we already have a user management application with all the related services.  So what we will do is will create the equivalent data was required for us.  So one of the user, DETI will be one and the user data V2 and then move on with implementing the you  are a versioning using those data was will implement the required methods.  What you are watching using model m'appelle and the next is to implement the cost parameter.  Roshini so that one also we will implement using the methods we define their next is implement custom  header versioning and then also implementing the media type portioning.  So once we implement all these things and then test it so it will go ahead and then commit and push  code where idy so this complex, our entire API versioning, so on high level we can even see the steps  required for doing so.  These are the detailed steps outlined in our best quality, Terfel implementing it.  So in every step what we are going to do, we have listed out here.  So what we'll do is like whenever we are implementing that respect to step as the starting introduction  will discussable each step and then implemented it.  OK, so we have built seven steps to implement each new order.  So we will do that in our upcoming lectures.    .  Thank you.    
