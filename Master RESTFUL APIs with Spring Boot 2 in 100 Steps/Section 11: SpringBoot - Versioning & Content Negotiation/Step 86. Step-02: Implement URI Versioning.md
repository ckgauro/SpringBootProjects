### Step 86. Step-02: Implement URI Versioning.md
Welcome back.  In this lecture, we are going to implement the Urata versioning, so let's go back to our detailed  steps and see them.  So if you see here in the control earlier, as I said earlier, we are going to focus on using the model  map or further converting our entry object to the digital right.  So for that purpose, we are going to use user model Mappa Control.  We are going to copy and then create.  It tells you that you are a worsening controller and then we are going to use Model Mappa to transform  into great detail and then we are going to implement things like using this.  We are going to transform and then we are going to implement two methods, one for one and then one  for V2 and for other versions.  You can see for V1 we are going to see V 1.0 slash 80 or we wondered once we can get multiple versions  here if we want.  And then for V 2.0 we are going to see it like this, which means we 1.0 and then 1.0, not at the same  level.  So in the same way, we 2.0 will have a different level, which means user data will be two will be  displayed for this, which means it is going to have the original address field.  So when we are testing the postman, we are going to use this.  You are right.  OK, so see versioning slash, you are slash users.  So we have given very thorough names so that we are doing the stuff in the right order.  OK, so there will not be any confusion when we are learning also.  So all the code will be useful for us as a template and if it is required.  So let me go here and let's go to the controllers.  We have the model mapper controller here, so let me copy that controller.  And then base state controller, right?  And I'll give the names, whatever I define here, user Urata versioning controller.  Right, click on.  Let me open this now word.  So if I see here you have the model, mapper, slash user, so let me change it to the euro, whatever  we have defined here, right.  So which is nothing but.  Rationing, slashing water, so whatever we are testing, all other services will be under rationing  slash, you are slash users, so this control at how it is unattracted with the rest controller.  So this is going to be a test controller and it requires mapping.  Is rationing slash?  You are slash users, which means you Tewari and we have user service word and also model map are operating  there and then we have existing method here stating that it's written by per user model per user.md
T will and will take the idea from the part variable and then what we'll do is we'll retrieve the  user OK, thoroughly that user object and then pass it to our model map of that map, that user and  pulling the model apart, that whenever I send the user for you, you convert it into user data.  So if you convert it to our V1 version, so Hollywood is going to be you will see.  So if you see here, our get mapping is going to be this way.  Even we can write it down.  Right.  So I can say we are going to use two things here.  Right.  So I will say and OK, so.  We wondered zero and another version we are going to use here is slash the one that one slash Heidi.  Right.  So this is the thing.  So this one we are going to use for.  Version one, right?  I can see you want to be a sir.  Versioning and hyphen and then we one that looks good, right?  So.  The return so far as it is going to be for the vivants version, it is going to be we can change it  at the end.  Okay, so now we have if you see here.  Are going to get the user in the user optional, and from that we are going to retrieve the user.  So now and then what we want to transform is we want to transform it into user data V1.  Right.  So instead of using the memory to silence the user, data will be one in command.  You've got to improve that.  And you're the name also user data V1 and from model number perspective, model map of that map and  whatever that user.  Right.  Whatever the user decided we have retrieved.  So that need to be transferred, transformed into user data.  We won the deal.  We won that class.  So what are we going to return the same thing.  Right.  User data.  Even so now we also need to change our method written by peer to user data on V1.  So let's change that one.  OK, so that's all.  So what we have done here is we have used our existing model mapper controllers method.  OK, what we have defined there in that what it is there is we send the ideavirus service and then we'll  be using that as we get the user in the user optional exact user object will get it here by using user  optional dockett and then that respective user object will pass it to the model.  Or that map as the first parameter means nothing but the source parameter.  My source is the user object and my destination is going to be user table V1.  So and then I'm going to return the same user data V1.  So this is about the first one, right?  So if you define the second one, it is going to be just me.  Two changes, right.  So let's also define the second one, too.  Right.  So let me get it down here.  Copy.  And then it is going to be me too.  Right.  So when we do, we said that we 2.0 will suffice for us.  OK, so I will say V 2.0.  OK, and we don't need to put like this for that.  Right.  OK.  And my method is getting somebody to write and it is going to return me to write instead of me when  we are going to return V2.  And Rita.  And Rita and even the return type is going to be to come on shift.  All right.  So now our user data will be told will be written using this.  OK, so let me save this.  So we have also implemented the V 1.0 method and the 2.0 method.  So in V 2.0 method, it is going to transform the user into user data.  What we do, which is nothing, but which also contains the address field.  So and then it will return.  So this completes our you are versioning implementation.  So we will move on to our.  Postman and then all right, so let me copy this.  OK, so let me go to the postman here.  That is it.  Yeah.  So we have already disappeared.  This is all the letter.  Posman projects are Posman requests.  Clearly separated so that at any time we contested thoroughly those things, so in the same way for  the divorce, also we have these things in the same vein that will create a new folder for our in England,  worsening and worsening.  So let me minimize these things.  OK, so in running, our first thing is our first request is going to be at request.  I'll say I'll say get yuzu by Heidi and then I'll say you want to be one, right?  So worsening.  So let me.  So this is one bad thing in Postman.  OK, so and what I'll do is like I'll copy our what can you use us whatever we have defined in our controller,  right?  So now what we are going to do is here we 1.0 and then let me say it here and let's call that, OK?  So we got the response.  OK, if you see here, the user name, first name, last name, e-mail, SSN orders, and then we don't  see any of the address Filkin for 1.0 in the same level test one more for one bad one and one that one  also didn't get any address field.  So let's do it for 2.0 in the 2.0.  If you see here we have a map of the user will be to where we have the address field.  So let me change it to zero.  Right.  So 2.0 and then save and then send it so we can see here address fill popped up.  So for using that you said about chinning when we are using V 2.0 we got the address fill that's all.  OK, so we can even say Wittels.  Serious we to so that we have the equivalent product for that one.  I will say we 1.0 and and Invicta, I will say May 2.0.  So this completes our implementation of your BASAD rationing, OK?  We have done everything with our GPA and then has to database with our existing product itself in detail.  And we have used the model Mappa for transforming our user object to user data.  So in the next lecture we will focus on implementing the.  But chinning using request parameters,   .  Thank you.    
