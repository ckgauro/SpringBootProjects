### Step 1. Step-01: Course Introduction.md
Welcome to this master masterpiece, Philippe, using Springbroot to I am calling the dictator and I  will be your instructor on this course.  So the goal here is we are going to use a single project and then incrementally build it by adding each  feature in an orderly manner, by creating separate branches for each feature.  After the completion of the course, GitHub is going to look this way.  Let's see that now.  So the project link for the database GitHub that comes less stack simplifies Springbroot hyphen building  blocks.  And if you see here, this is the GitHub screenshot.  So if you click on the master dropdown, we can find the branches available and each branch will have  the continuous whatever we're doing as part of this, of course.  So far at Ground Zero branch, it is like a simple basic springboard initialize project and they will  be available and then zero three will be deployed.  With a management service like this, it continues.  So all the sections will have equal branches so that we can directly check out and then use them from  coarse content perspective.  We are going to understand and implement multiple topics here.  So first applicable to this Willowby, we are going to start with and then understand what are restful  and then what are its differences with the software services and then move on to the next letter for  understanding managing the Spring boot projects with GitHub and then also implemented simple high level  service.  So once we implement the service, we'll move on to the.  with Restful API  with Springboot  data and then head to so we are going to build a complete realtime API   using sprint data JPA H2 database.  So once we build those things, we'll move on to the exception handling with this one status exception.  So we are taking you time project like a building restfully a place with Spring boot Today Parenthoods  two is like there will be a lot of difference in implementing the features with the static oralism maps,  whatever we use to introduce the concepts.  But when we are using the real time project, when we are applying the concepts, there will be a lot  of difference how we use it.  So and then how we are going to write the code for them.  So in those lines.  So we have users in that Section three.  Let's flip a switch, bring that in and then introduce, introduce the response status exception, exception  handling library.  Or we can say as a package which recently introduced as part of the spring fire so that you will have  the details about defining the history to be status quo and also the messages directly inside that exception.  So even though it will be useful for the most and also for the small scale, but if you want to implement  exception, handling a large scale for bigger projects, it is good to use the global exceptional handlers.  So to design the global exception handler.  So we are going to design the global exception handler using controller advice and also the list controller  advice.  So in addition, exception handling primarily comes into the picture due to the validation failures  or anything.  So for that purpose, we will implement the validations and then what?  Data, validation, failures, whatever the exception, Harker's, we are going to handle them using  the global exception and in this section.  So moving on, the next section is going to be the JPA to many association.  Ideally, this section is needed for the next section, which we are implementing, which is nothing  but a springboard headways.  So from Haber's perspective, that will be something called self-locking and then relationship linking  in the relationship, linking to demonstrate exactly what is a relationship linking and then how we  are going to leverage that features from year to year.  So we have implemented the Section six, dippie one too many association, but it's good that more or  less like 30, 40 percent of dippie concepts are also covered here from building.  That is a using spring data depinho to in addition to dippie one, too many association also cover so  close to three layers of content discovered from the perspective here so that we get good hands on on  the realtime project.  And then we're also applying the realtime concepts directly to your real time project.  So that also changes our understanding level from concepts perspective.  So moving on to will implement the springboard internationalization and then we'll also implement the  springboard filtering.  So from the perspective we will implement.  Static filtering, dynamic filtering and also the filtering with the new annotation so that the static  filtering will just ignore this and ignore properties and in dynamic filtering will use mapping the  exact values.  And then finally, we'll also use the additional filtering with the Jessan.  You so will see three types of filtering dedicatedly Novara, Section nine, and then you'll want to  use in extension's to filtering.  You can also use data transfer objects to convert over into objects to the device or detours like did  you object to entities.  So we have used maps struct and then model mapper here to demonstrate our identity to digital conversion.  So we are currently latest in the market.  And then the next is Springwood rationing and the content negotiation.  So from that perspective, what we have done is we have implemented all types of versioning, whatever  is available for us, which is nothing.  But you are watching Changing Our Head versioning or MediaTech versioning.  So like this, whatever the four types of watching available we have implemented.  In addition, we have also looked into the content negotiation going on.  We also implemented swagga integration and we have implemented the model in the model and then controller.  We have the specific annotations available for swagga and then we have applied them and then understood  the differences and then how we are going to apply it.  In addition, we are also seeing how the DSR three zero three validations, whatever we apply at the  entity level, also generates a documentation with adding additional dependencies to the project.  So we have seen that one too.  Now moving on, the next is going to be a springboard actuator and then admin.  So the key thing here is any application we develop, its monitoring plays the key role.  So using actuator means like in Spoonbill, we have lots of latest information available from Attwater  perspective.  Lots of new endpoints came into the picture and the way it operates also changed.  So we have looked into all the endpoints looking for health and then all the different points that metrics.  And then there is one more dependancy recently came, which is nothing but the springboard admin.  OK, so which we also call admin server.  So we have also installed that admin several.  We have created equal and package for that admin server as a separate project, and then we have integrated  our current building blocks application with the admin server and then we help build all the content,  which is exposer, but we are actually 10 points on the admin server going on.  The very important feature is the micrometer, the top notch feature for metrics perspective from springboard  applications.  So this is very, very.  Good feature from Springwood perspective, so it exports the metrics for springboard applications to  the desired.  Monitoring tools so that are close to 15 to 16 monitoring tools available in the market, which are  which springboard to support, and it has a version which can export the metals from Springburn, those  applications.  So what we have done is we have implemented one basic one with the mixing console and we have also implemented  one more integration with the app optics, which is a so product, so that whenever it stats are generated  in our application, both will be exported to the app optics and then we can review them on the app,  our pixel application, which is nothing but this Aspasia application in browser.  And we can create the dashboards and also see all those things.  We have user data collection and that in Posman to generate the law and then verify our dashboards and  its live states and then also times time, this database.  So how the times it is data we can view and all the metrics we can see whether we have seen all those  things.  So this completes the course content description about what we are, what we have, what we are going  to understand and then learn from this course.