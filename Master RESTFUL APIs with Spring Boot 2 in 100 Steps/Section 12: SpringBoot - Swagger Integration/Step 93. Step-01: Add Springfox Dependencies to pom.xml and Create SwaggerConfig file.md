### Step 93. Step-01: Add Springfox Dependencies to pom.xml and Create SwaggerConfig file.md
Welcome back. In this lecture, we are going to be good brunch and then add our Spring Fox Swagger later dependencies to our problematic symbol and then we'll create our swagga config file so that our application, Springwood application will be enabled with the Swagga. And then we will test both the Jason and Jason who are in this world that you are you are you Warren? And then we'll move on to our next lecture. So let's go back to where we are here. So we create our first step that is adding the new GI branch, OK? So our master is in sync with our previous brand, so contract negotiations will create a branch from Master, right? So I'll say to Wellspring, good swagger, API documentation, so continue. So my JVM isn't running straight. Let me stop it, OK. So anyway, we are going to make from that simultaneous right. So anyway we need to restart it and stopping it. So let me go here to our Walmart example. Right. And copy our two dependencies. One is Spring Fox Swiger and the other is Spring Fox, Swiger UA. And both has the version about nine that to OK, which is the current latest version. So let me go here and then added at the and. So one thing we need to remember here is we need to restart our Ambre Tomcat whenever we make or add any new dependencies to our Bombach XML, so I have already started it. We should be good. In the step three, we are going to create swagga config file annotated with configuration PAPEN Spring that it's a configuration file and then annotated with the swagga to OK to enable the swagger to so and then we're going to create a had been. And then once that is completed we are going to save it and then verify the following things. OK, so optional user response fixes we will do in our next lecture. OK. So for now we'll move on with implementing these things. So later I have made a note of it here. Right. So fix optional user responses. I'm going to do it at the step five. OK, so we will discuss about that in detail when we are implementing it. OK, so now let's move on to our role creating swagga config file. So we have a conflict package here. OK, no application. So in that, I'm going to create a new class named Swagga Config, OK, so I'm going to. So first we are going to annotated with configuration. Right. And put it. So next is enable. Swagger, too, right? So done so the next thing is to create our docket, Bill, so I will say a public docket EPA and then I'll see it on the new docket. Right. So when returning, I'll provide the arguments. So documentation type that we are going to tell that that we are going to use the watch and two of swagga specification. So documentation type is swag that we are telling the docket that we are using the swagga to. And we are also going to say Sellick. So what does this relate to is what's happening so we still don't import the docket. OK, yeah. So and then once you select OK, so the Senate creates a binder which is used to define which comptrollers and which of their method should be included in the generated documentation. So under that will select the purpose. Right. So EPA's defined the classes, which is nothing but controller in the model classes to be included. Here we are, including all of them, but we can limit them by this package. Are class sanitations and more options available. So in the next upcoming lectures we will restitute with the best package is Fano. We will say request handlers let us not any. So I will say. The Quest handler, selector start any light, so now APIs are completed, so the next part's OK. So but select us OK, so Pott's allow us to define which controller method should be included based on the part mappings. OK, so in a single controller also we can hold specific parts and then provide a part of it and buttons to be finally specific methods to be exposed. OK, so something like that, whatever we want, we can do even it allows the digits and then and buttons for it for us. So I'll support select test that any so that fano all parts are included. Finally I will say. All right, so what this does is like no it will be built. OK, so now our application is enabled with swagger. I need to restart this. Has it been in the spring context. OK, so come on, you've got to annotate it would be the important stuff. So one final thing here is. Our swagger, metadata and our swagger. You are you are OK. So I'm going to write them here so that whenever we are testing, it will be handy for you. Right? So I'll see localhost. AT&T slashed me to slash Ippei hyphen dock's. So this is our swagga metadata. You are. And this is swagga. You are you all right. So that is nothing but localhost AT&T slash. Swear that you are not looking. So let me save this, OK, so now let's start our application. Then, as I can say, Springwood up. So it started OK, so no issues, so let me make it bigger. So let me copy our metadata. You are all first, OK? So and then pasted here so that all the control information, everything will be provided here in the Swagga Jason file. OK, so this is the address and metadata we have got the same thing will be shown in the nice format, which is nothing but our swaggering way. So this is a little uneasy, right? So what we will do here is we will try to take this unmoral and then we have the same Gissen using UI. OK, so let me see Swagga. You write out his HTML. So if I see here that part you can see here, this is the API documentation. So you can see here the documentation and the basic rodell and the API documentation subheading terms of service license. You are a lot of stuff. We can put our contact info for everything. So that's about this area no matter what. So no one coming to the controllers. You can see that we have the basic error controller, Hollowell controller or the controller or the notorious user. So whatever the controllers we have created as part of all the previous sections, we can see all of them listed here, including the very least incision's like user media type in controller, user model, map controller, everything OK? Everything we are able to see here. This is about the controller section in the same way will also have the globals. OK, so whatever the models we have in our application, but also will be much like nothing but the beans. Right. So we can see here everything. OK, so this is our user model. OK, so user details, user data will be one, user data will veto. So whatever that means, we have defined all those things were displayed here. Right. So that's about the models. Now let's look at something here, which is nothing but the basic error controller. OK, so this is we didn't define this. OK, so how will this coming? So that's coming because we have selected nothing but the request handler select us any, which means from all packages it will scan and then send it. Know what we are going to do in our next step is we are going to restrict it to the package level, which means we have something called our packages are at the level of. To simplify the services controllers so we will even less dictate the services or code packages here, right, Comstock's simplify other services so we can restrict so that only our controllers and then our models will be displayed instead of everything. OK, so this basic level of control is coming from the spring. OK, so that's about the first three steps which we have planned to understand and then implement. So those are creating a brand, adding dependencies and then creating a swagga config file and then using our swagga metadata, your model and then reviewing our swagga you where you are. OK, we have also created the bucket built and then annotated it with Swagga two and then configuration both the things. OK, so in the next lecture we are going to customize our header. Right. And we'll also look into adding Guevarra restrictions to our request time slots and then also the part select us. Let's see how we are going to do that in our next lecture. . Thank you.  