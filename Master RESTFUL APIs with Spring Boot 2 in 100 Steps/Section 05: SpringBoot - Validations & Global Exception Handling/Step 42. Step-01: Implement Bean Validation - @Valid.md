### Step 42. Step-01: Implement Bean Validation - @Valid.md
Welcome back. In this lecture, we are going to implement the bean validation, so if you see our steps here for bean validation, so what we are going to do is in the end here, we are going to implement validations on identity objects, OK, which is nothing but user entity variables. OK, whatever is there there. So we have user name and also first name so far. I mean we are going to apply it did it not empty. OK, and we're going to also add the message saying that username is Mendeleev. Please provide username in the same way for the first Memphian. We're going to add annotation sites with the minimum as two character. OK, so if you want it is going to fill in the same way here. If you don't send any user name value, it is going to fail. If it's an empty user name value, it is going to fail. So our important thing is when it is going to fail and then what is the exception we are going to get? That is the thing we need to focus on when we are implementing the validations. And once the exception comes home, we are going to handle it. So which is nothing. But whenever we are implementing validations, no one is OK. So it watkins's it is going to fail and in that case, without exception, it is going to throw that number to and hopefully handle that. Exception is rule number three. So we need to be aware of these these three things when we are implementing the validations. So what we do is we apply these two things to our respective entity objects there, and then we'll go to our postman. And then in the request of the creators of servicing the body for the first name, we will dispute one character so that this will feel right. So because it said minimum to the same user name will just send the empty string so that this will fail and then we'll see what will we get it. OK, so we have not implemented anything special here. So it will be like an exception from the dippie level right away because then it will communicate to the back in his database. So you'll get a deeper level exception and will verify that. OK, we got it. So now after that we move on to the controller and in the controller, layer four will enable the validation using a direct value for the request. But what we are sending will add elements like a valid annotation to that. OK, and then we'll go to the postman and test for a booklet with the service and we'll send the same data. What we have said, cefazolin with one character in the user name with the MVP's. So what happens is like we get different, another bad request, OK, and then we verify the log. It says that method are not valid. Exception will be solved from the logs. So which means this respect, the exception got resolved. OK, so we'll see more in detail later about this exception in the next step. But this exception got resolved and by default we got the four hundred bad requestor history to be status quo. But we don't get any more responsible. We will not get any of this. So let's see these things in step zero one so that we know that we got the X, we got better and then how to handle the exception. Will more on 022 handle this by creating a global exception and handling the class and all those things? OK, so let's move on to just implement these things for now. OK, so first thing is to implement validation. So I'm. So let's go back to that idea. So this is a variety, so we are in the zero five validations, global exceptional high level bank checked out. So I'll go to that lady and now I'll go to our user entities. Right. So this is the user entity. And if you see here, we have this. OK, so let me apply also one more annotation here. Did it not empty? So and then we can say, come on, shift auto import so we can say that deregulation, OK, the same way or even the highway network later. It's up to us. OK, so then your deregulation. Furneaux so and for first name also with the car payments like a great size and then MRD suggested the message is bigger one here, whatever I have written. So just to ensure that save time I'm just copying those things. So what I'm doing. OK, in addition size with minimum two characters. OK, my first name should have at least two characters. OK, so I'll import those. OK, so Giwa actualisation constraints. I also got imported so now I will save this. OK. So currently this might not have been running. So let's start over Davian. So let's start the JVM now so I'll see if I click on this HealthSpring boot up. OK, so my Davian got started, OK, so we'll go to the postman, no. OK, and we'll go to the creative side, right? So we should be able to use it now. And the first thing is we are sending one character for the first name and use them. We can send it as empty deck. OK, so let me send it. So now if you see here, we got the 500 internal server. I still think it is a bad thing, which we should not see OK, from this client perspective. And that is not a good thing. And then we should definitely handle that. OK, so no, we will go to our error message so this year could not come a transaction. Mr. Exception, is Dalek's persistance. Rebecca Benwell committing the transaction. Right. So we got the end of an exception, OK. So now instead of going to JP and then getting the an exception, OK, so we can handle this, we can validate this at the response by itself because by level itself, whatever it is, it that level. OK, so it will go to our controller user controller and then we'll go to work with user. Right. So this is a user matter and what we do is before request by the annotation will add the. Valid annotation and then. We will put it OK and then we'll save it. So what this does is likely to invalidate the Red Cross border, whatever is sent here itself. OK, so no, go ahead. And then again, that's the same thing. OK, so let's send the same thing. So if you see, you know, they got the 400 page request, right. And we got the default message, which. Spring is constructing for this, OK, so we have got a different message saying that I will go down and then see it in detail, see, so like I said, we have got here, OK, so size, user name, first name. And if you see here, first name should have at least two characters. This is coming from our message field. Look in the same way for username. Also username is mandatory for all. Please provide username. So whatever is being provided by default. OK, but. Responds by a request by the validations. It's like being validation looks good, OK, but it looks very big, OK? But when when we plan to do these things, OK, and at every level, if you want to define a standard exception handling procedures, then all these things doesn't look good. Right? So it's like if you have four or five frames which are which you have standardize for the entire global exception handling, then we need to handle this exception also into that framework. Right. So those things we can do our next step by implementing the global exceptional. So let's go back to the console log and see what has been thrown. OK, so if you see here in the console log, it said that method argument, not valid exception. So it is no disrespect to exception with the two errors, validation failed first time. So argument. That's why I'm so OK. So which means like whatever the exception now thrown his integrity to resolve this matter argument, not valid exception. OK, so in our next step, we need to handle this exception and then send a custom message, OK, customer response body and should have this big information, whatever it is giving. OK, so customer responds with timestamp details and then some message. OK, so that that should be good for us. OK, which is like blah blah of handling model. OK, so it might be even more but even more famous and all those things in real world. But I will try to implement and understand how we are going to implement the global exception handling with the controller in the next section. So I'll see you in the next lecture and building by. 
### Step 43. Step-02: Implement custom Global Exception Handler - @ControllerAdvice.md
 Welcome back. In this lecture, we're going to implement custom global exception and let the U.S. come to another place. And also we are going to be looking to respond to the exception handler class. And we are going to also override the methods defined in response and to the exception handler class. So and then implement those methods. OK, so let's go ahead and then see what all our detailed steps you are going to implement as part of this step zero two. So if you go here, so we are going to implement a custom global exception handler saying that exception. Well, going back to classes. OK, so first one is customary for custom and we can tell you in detail customer details. OK, so we going to create a new class named Customer Details and we are going to define variables like that message and then our retails and we are going to add things constructor and then get us inside that nothing. But we are going to create a customer that details being OK, which will be helpful for giving the responsibility for all our exceptions with a big message and then other details. So in the exception matrix elements like the exception package itself, we're going to create one more class named customer global exception handler. OK, so what this going to do is this is the core handler class. It will handle all the exceptions, whatever we want to handle in our application so we can keep adding all the methods inside this class for what are the exceptions we need to handle globally. So we're going to create this class and extend it to respond to an exceptional handler. OK, response to the exception handler is the core class, which will have the details about all these. It will have the methods for handling the fuel. Are the important exceptions OK? Mainly related to the services. OK, so if you see here, you're also going to annotate disrespect to class with the controller advice. OK, so that can be applied to a wide range of controllers could continue that. This will apply means like we can define the Global Code of Global Error Handling's custom handler. Right. Whatever we are defining that can be applied to a wide range of controllers using controller advice. So that's the reason we're going to annotate our custom global exceptional handler class with the controller controller advice. And next, we'll move on to implementing a handbell method argument not valid. So there steps to zero one. We know that method are not really the exception we have seen. OK, so it's a common method will be there in the response, the exception handler. So we're going to implement this method. And then what about the existing method? OK, from Lesperance into the exception handler and then we're going to test the quality of the service with the same things. What we have done in step one, which is first name one character, and then use a name with them the string and then modify their response. So we should get our custom response, whatever we have defined with the date message and then other details. And also we should get the story before another bad request. So we are going to perform all these things in this customer. One exception handler step now. So let's go ahead and then implement that now. So we'll go for it and then implement the same thing. We'll start with creating a lot of customer details. Plus they come back. So we are know now. So it'll go for exceptions package, so know exceptions. Currently we have used this exception and use a not from exception, these details which we have implemented as part of response dataset, an exception, which means like if I remember in our response status exception, you can see it here. Right. So during this implementation, during this section implementation, we have defined these error messages. OK, so now whatever. We are defining the global exceptional handlers. Right. So we should ensure that both like we are not colliding with the response status exception, the letter, the exception handling and our global exceptional handler. OK, in this project particularly, it's a good practice that, as I said in response, status, exception, conclusion section also that we can use both things, which means that global exceptional handlers using controller advice and also response status exception, which has been included as part of spring fire. Both things we can use it. But one thing we need to ensure is that whatever response status exception is handling those exceptions, we should not be finding other notable exception handler. And whatever global exception Handler is handling the exceptions, we should ensure that those were not handled by this one status exception. So which means like there should not be any confusion state for the system to decide which one it should use. So we should have. Carefully, so we are doing that now, and that's a good thing, right, which means that we are going to learn a lot of stuff here. So now go to new and then create a class. And are exceptions seeing custom error details? Right. So this is our custom details class and. We can just give the message messages quiet. Simple cost. Custom. Her details being OK, so just we are defining this and then we'll define our three variables. So one is a private bit and then we'll define it as our timestamp. Right. So the second is private string and then message whatever we want to provide, OK? And the next one is private string and then other details. Whatever we want to report are we can even see a message, too. So this is a generic message and this is error message. So I'll say the details. OK, that looks good. OK, so now we have defined our variables, right? So now we'll create our field constructor. OK, so let me create the concept of using fuels and then generate the constructor. OK, so next is so this one. Let's import this data in Java util date. OK, so that's good. And then also generate the constructors so to get us right. So select get us and then generated. So now we'll see these as getters and. This is thrill's constructor and then let's see if this OK. So now we have our custom error details class created. So now we'll move on to creating our custom exception, custom global exception. Handler. OK, so. So let's create that now, so I'm in the exceptions package and we are seeing classers. Custom. Global. Exception handler. OK, so we are creating a new class custom global exception handler and this class, what we are going to do is let me make it bigger. Yeah, so it should. Extends right response and the exception handler, slow response entity, exception handler. OK, so and then import this one. We should we could know, so now if this custom global exception handler should be applicable to all the controllers. So what we need to do so we need to add the. Controller advice. Right, so let's import that package, too. So now this was discussed and global exception handler will be applicable to all the controllers, whatever will define the code. Yet either it is exception, handling include or whatever the code. OK, whenever we are annotated with controller advice, then it's globally applicable to all the controllers. OK, so now we will go ahead and then override one method. OK, so first we like the method name here. My third argument. Third argument, not valid exception like this one we are going to handle here, so let's go response and the exception handler ones and then see what is present inside that. OK, so. So what we'll do is we will say. Response. Entity exception handler. Right. So let me open this, OK, so a convenient win this class, OK, this one. So if you see here. In this class, we need to go to the if you see in detail, OK, so that it's the exception handler for all of these exceptions has to be a request method, not supported his GTP media type not supported. OK, not acceptable media type, missing part, variable exception, missing cymotrichous, parameter exception. So like this we can see lots of exceptions which can be handled using response and the exception handler class. So in this our thing is method argument, not valid exception. So if you see here, it's equal in method will be defined in this response and to the exception handler. So let's go there. OK. So if you see here, so this is for the Questors GDP hand initiative request method not supported in the same way we can search for a method argument not valid. OK, so see here it is. OK, so custommade the response fair method argument not valid exception. So we are going to take this method and then implement it the way it is required for us. OK, so we'll copy this method, OK. And then use it in our custom global exception handler thing. OK, so what I'll say is like control v OK. And then I'll remove these things for whatever the written moonlighted. The weight is required for us. OK, so. If you see here, handle method argument, not valid, right? So what we're going to do is we are going to override this existing one. So I'll. All right. Right. So now what I will do is I we have something called the customer details. Right. Using this will set the details, whatever we need for this list. But the exception, method, argument, not valid exception. Whatever the message we want to send. We will send by our being, OK. So I will define our being here. OK, a customer, other retail sales customer I love details is a call to new customer. Other details. Right. And. So inside this, we have three parameters, OK? So one is a bit messy and then other details. So the first one is dead, right? So I'll see. You bet. In the same way, the second message, so I will say this as a name, whatever we want to argue, OK, so far, no, I'll just give that it is coming from Matara argument, not valid exception. This is just for our testing. Right. So I say. From my third argument is not valid exception, OK, in global exception, handler, OK, detail Zilkha shortcut for us, OK. So now and the other one is the third one that also is trending. Right. So what we'll do is we'll bring this down here, OK. So and here audiences will get something from our exception. Right. We have metadata argument, not valid exception. So from here, we'll try to get some better details. Why? Because our third parameter here is error detail, some additional information about our error rate. So I'll see you next, Dot. OK, so whatever we want, we can get it, OK? So I can say get localized message, whatever the string type me how we can get those things so I get localized message or get message so we can get. So I'll try to get some message here. OK. So initially we'll change it and then implement something else later. OK. So now we have a word. Customer details to define. OK. So now we need to return the response entity to this. OK, so let's return the. Response entity, right, and. What are we going to return this customer details, right, so customer header details and also our history status. OK, so I'll see EDP status that bad request. OK, so I'll send that bad request. So. I can see the object here, so this should. Konsta response entity, right? So I need to say, New York, we should be good, OK? I can even put to death that. OK, this should be good. So now let me save it, OK? So if you see what we have done is we want to have a response to the exception handler class. So why are you destroying error. So Jabor, you still get little input, OK? OK, let me say it, OK? No errors, we should be good. Yeah, so what we have done is we went to the response and to the exception handler class and then we tried to find our Matara argument, not valid exception, related method here, and then copied that method to our custom global exception handler, our class, whatever we are defining here. And then we have already the existing method handle that argument not valid. OK, we annotated it with. All right. So now we ready for that matter, whatever we want, we can write inside this. So what we have written is we have brought our customer details being here and then said the messages inside that. And when we are retaining that customer details information back to our whenever this exception happens, then return these things. We are saying, OK, so and then you're also sending the status should be status, that request. OK, so this completes the implementation of method argument, not valid exception, handling using custom global exception handler, which extends the response into the exception handler. So now we'll go to the postman and then test it. OK, so this is the thing. And if you see your username is empty and first name is. So let me send it, OK? Calm down. So if you see statuses 400 bad reckless timestamped, we have got a message. So I have a message from metadata and not valid, exceptional global exception handler. I have defined it without it and other details you can see validation failed for I have said the exception that get message right. So using the exception. But let me say it. You have got the validation feel for argument in public and then you have got all the details. OK, it said was rejected in the first name rejected. You have got some information which is good. OK, so this way, whatever we want, we can define another custom global exception handler and then handle the methods, whatever we want to handle, which means like whatever the exceptions we want to handle, we can handle. So this is what we have done in this section. So in this lecture, in the next lecture, we are going to also work on another method in the same pattern so that we get a little more experience on implementing, using less brons and with the exception handler. So if you reiterate what we have done just one more time, that we have created a customer details class and then implemented messager, other details inside that and with the exception layer itself, same exception layer itself, we have also implemented custom global exception handler and then we have extended it with the response and with the exception handler. We have annotated it with controller advice and then we have implemented a handler method admin, not valuable, copying it from response to the exception handler. And then we have overloaded the existing method and then implemented it with the message whatever we feel is good for our organization. And then we have to start with the postmen and which confirmed that. Our customers are just coming out expecting the global exception handler when we implement the global exception handler
