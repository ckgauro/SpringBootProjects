### Step 40. Step-00: Introduction to Spring Boot - Validations & Global Exception Handling.md

Welcome back. In the U.S., we are going to understand and implement springboard validations and global exceptional handling. So if you see valuations are the key thing for any of these modern Web applications today, even further, the steps validating user input is a very common and key requirement in today's world. SoSpringboot nable provides strong support out of the box for validations, suspended support, seamless integration with custom validators, but de facto for performing validation hibernate validator. So there certainly is a specification of Java. You prefer being validations, which ensures that properties have been meet specific criteria using annotations such as not Nadelman and then Max. So if I see that wallet annotation, then Springbroot finds an argument annotated with valid, it automatically bootstraps the GSA implementation, nothing that happened that validated and validates that argument when the argument fails to pass the validation springwater method argument, not valid exception, exception. So this one, we're going to anyway test it in our upcoming use cases. OK, so that's the reason I have put it very specifically here. So if I seem to be validation to specification, is that primary thing which we can look into that is that you are going to have provided where we can we have the means to have a net validator and validation. Everything okay. So we can reference there. OK, so let's not too commonly used the validation annotations. So from validation annotations perspective, very commonly used from our entity are from our moral perspective. Right. So those are natnael, OK, so that the annotated property values natnael in the same way. Other annotation is size, which we very frequently use to talk about the little property value has this size between so inside tribute Min and Max and continuing to that we can have Minin Max annotations which validate that the property has a value not smaller than that molad in the not the spec to attribute. So another one is email ballbuster. The annotated property is accepting the valid email address or not. So other thing is not blank. Validate that the property is not white whitespace. So it was not empty. Validated that the properties not nahlah empty. So like this means like if you keep saying there might be many, many, many, many occupations from both hibernate validator and Angelique's validation perspective, but on a high level, then coming to Springboro services and then at the moral level, at the entity level very frequently used, I have listed here for our convenience. There is a certain relative stability, the property values true. So movement to global exception handling. OK, so this is the key thing, which is the organization focuses when they implement their applications. So it applies to any of the web application or services. Right. So in our case here we are building Bisping Springbroot RESTful Services so far that also earlier in our previous section we have implemented the exception handling using respon status exception, one of the class which had recently provided for in Spring Fiacre. So which will be more like a dynamic hasn't been everywhere. Wherever we want, we'll be able to define that respect to the exception and then use it. OK, but Trouillot exception and then use it. But here so we have a general look, OK, our entire application exception handling so we can implement global exception handling. So why we have put this in combination with validation is primarily so whenever I'm doing any validation anyway, it is going to throw the exception. Right. So and we need to handle that exception. So for that purpose, in our previous section we focused on custom exceptions like username, not phone. That user exists, all those things which we handle using response, status, exception, message. OK, so but now we're going to focus on global exception, handling for the exceptions which are going to be triggered using validations, OK, so that we have it in picture from exception, handling perspective in the entire spring. OK, so from again we're going to look at from Springbroot three, that one looks like we're a threat controller best has been one of the key annotation. OK, introduced in Spring 3.0. OK, so and from that time still people are still using it primarily for the web and spelling it with NBC. But even for the controllers, we can use it and then it's frequently used. So if you see controller advice allows us to write code that can be applied to a wide range of controllers. It's not only for the exception handling, but for any of the global code, which we want to define across controllers. We can use the controller advice, right. So this controller must play a key role when we are using the global exception handling so we can create a simple global exception handling class so that it will be annotated with controller advice. And the same thing will be used for us for defining the types of. Exceptions which can be handled from Disrespectable Plus. So that's what we are going to do. So the other thing is by default, countermelodies annotation will be applicable to all plus that use controller annotations, OK, which also applies for this controller because that is also one of the controller. Right. So, no, the exception handler. Right. So this is one more exception. Handler plus annotation for handling exceptions in specific handler classes or handler methods. If you use it with controllers directly, we have the need to define it for controller. But when we use it in combination with controller advice, it will be only used in the global exception hand in class, but applicable to all controllers data controller advice capabilities. OK, so primarily we are going to use this exception handler in our controller advice, so we are going to see how it is going to be. So the next user, the controller advice. So this is again, I'd run sort of model out for controller advice. OK, so we'll see. What is that? OK, service controller advice and the combination of the both controller advice and the response body. So in controller that most we are supposed to manually define our response body, but from less controller based perspective, it's a combination of both controller, less and less body. So we can use the controller at sanitation for handling exceptions in the restful service, but we need to address one's body separately. That's about the rest controller and the controller differences. OK, so but all in all, whatever we are seeing here, OK, are used for defining a global exception, handling the scenarios so that you use this combination. How we have arrived in implementing, which we are going to implement in the next few seconds, is listed here. OK, so the Fustiness controller advice and the response and to the exception handler class. OK, so this is one more class for handling the exceptions which are there are predefined set of exceptions defined in this class from rest services perspective. So mainly from his duty perspective, we can say, right, so all those exceptions will be handled using the spontaneity exception handler class. So I bet we can use the default, which only gives the history to be status quo or we can override. The methods are defined in this response and with the exception handler class and then also give our custom message board whatever we want. So we will implement our custom message body by automating the methods, presenting this response and to the exception handler and see how it is going to be OK. So that's going to be. The important thing which you are going to implement so unabating is not that argument, not valid exception. So this one by default, it is defined in the response and the exception handler. And whenever this method argument, not valid exception is resolved, automatically we get a 400 bad request tested in response code, but we don't get any message. So what we're going to do is we are going to override this OK, right. This default method and then implement it so that it will be in line with our customer response, what we have defined so that we get both to be status quo and the request and also the custom at a response message board. OK, Jason, so we will do that. And once we do this again, so it's a practice, right? So when we are doing this, we might discuss multiple things. OK, so and then to have additional practice for us, we'll also do one more time the simulator run, the test method not supported exception, which we are going to be disrespectful to request method not supported exception in response and to the exception handler class so that we have a good amount of practice when implementing these two things, so that you can take it as an assignment for implementing other exception classes present in this response and to the exception handler class to implement. So in this combination, controller advice and in response and the exception handler class, we are going to implement the two scenarios here. OK, in the same way when we go to the controller advice and exception handler. OK, so this exception handler is the thing where we hand, we define our exception classes right behind this exception handler. So rather than it is for the predefined exceptions like constraint, violation, exception, we are going to implement one scenario. And so as we implemented a predefined exceptions like system provider constraint, violation exception, so we will have a feeling of also implementing the same for our user defined custom error exceptions made custom exceptions. So what we do is for custom exceptions. Also like we have one method which we have created for something like a get user by user name. OK, so this is one method we have which we didn't implement any exception handling or the response status exception message which we have implemented earlier. Right in the previous section. So we left it one partly because we want to implement it here with the custom exception user name, not for an exception. So we will implement this user name, not one exception. Forget user by user name method, and then we are going to define it as a method of placing an exception handler so that whatever that response message we are triggering for exception for the user name, not from the exception, it will be triggered from this hospital exception handler. OK, so we're going to see that in the demo. OK, so the next is the best controller advice and the exception handler. So this is one more thing. OK, so we are going to implement that with custom exceptions like the name, not one exception. So whatever we have implemented here in the controller advice, the four custom exceptions like this. OK, so I will go in there and then you're coming back that advice class, which means let me if you come in this country annotation, then this global exception handler class will become involved, which means it will not be in use for any of the controllers. Right. Because this will be whenever we enable it, then it will be in the context to say that it will be applicable to all controllers whenever we come in this, it will become a general class of models for us. OK, so I will go and then comment this out and then we'll create a new class custom. OK, custom controller exception handler class. OK, which is nothing but another global handler class will create with the rest controller advice and then we will implement that in the name not one exception in this and whenever we test that. So instead of this, we should be able to say this from this because this is commented out at the controller at this level. OK, so we'll see that in particularly just to understand how the best controller adviser, how we're going to implement and what will be the pattern for that for that purpose. We are also implementing this. So that's about it, even if you want for when we are implementing. Right. For predefined exceptions, OK, for the entire or whatever it may be. My exception. OK, I'd like to put an exception handler dispute exception, that class, which means for all exceptions, it is applicable. Right. So you can be trained for the exceptions and then in the exception handler and then it will be applicable for all the exceptions, whatever the customer said you want to trigger so that the customer, whatever stupid response could. One important thing here is that British controller. Later, we are going to say an annotation response status, which is another indication we are going to use it. OK, so that's a very bad advice. So no one, no implementation steps, right. So as a first step and step. Everywhere, wherever we do this right in all of our sections, we're going to create a good punch for validation and this global exception handler. Right. So we'll keep up and then from then we'll start our implementation. So we'll clean our massive plant and then create a new Blanchot validation and global exception. Handler And then we'll move on to implementing validation. So this section is about validations and also global exception handling. So it is a combination of whenever a validation happens and it fails, then it exception will be fired and how to handle that exception. That's about the overall situation. Right. So implementing validation will implement validation and will follow it step by step approach when we are doing the validation. So which means like first we will implement reporting validation. When the error occurs, what will happen right. Means like you will get a little exception because it's a project that. So then we'll go and then implement with a trade value to the validation for the request body right at the time. We'll get that method argument, the exception not from handler. Right. So that that one will be fired. OK, so and then now we're going to handle it. Right. So then you'll want to implement custom of global exception, handler using controller advice and response and to the exception handler. At that point, you will handle that retrospective method of the exception here. OK, so and then are not really the exception. You are going to handle it in this Tirpak by implementing a custom global exception handler. So the next Wimborne implementing exception handler for this method not supported exception. So that's the thing. OK, by picking, by writing the method defined in response and to the exception handler class. Right. So I will move on to the next step, which is nothing but implement exception handler for custom exceptions like username not for an exception using exception. Handler annotation. Right. So that is the thing. So one more step. So here's what we'll do is like we will implement the part where validation software, which means like in the path variable like that user by user ready. Right. For that part, validation so exemplary should not be zero at any point. So you can say that. Did it mean zero? OK, I mean, one woman means at least only one. It should start from one. OK, you should not such but zero. Right. So like that if you implement it will that constraint violation exception. Right now we are going to implement it using exception handler in customer level exception handler with controller advice. So we are going to see that and then we'll move on to step six, implement global exception handling using the rest controller advice. OK, so that's about all the things which you are going to implement in this country that we are going to implement the further one of the user name, not from exception, and then we're going to toss that thing. OK, so I'll see you in the next election. Bye bye. Thank you. 
