### Step 43. Step-02: Implement custom Global Exception Handler - @ControllerAdvice.md
Welcome back. In this lecture, we're going to implement custom global exception and let the U.S. come to another place. And also we are going to be looking to respond to the exception handler class. And we are going to also override the methods defined in response and to the exception handler class. So and then implement those methods. OK, so let's go ahead and then see what all our detailed steps you are going to implement as part of this step zero two. So if you go here, so we are going to implement a custom global exception handler saying that exception. Well, going back to classes. OK, so first one is customary for custom and we can tell you in detail customer details. OK, so we going to create a new class named Customer Details and we are going to define variables like that message and then our retails and we are going to add things constructor and then get us inside that nothing. But we are going to create a customer that details being OK, which will be helpful for giving the responsibility for all our exceptions with a big message and then other details. So in the exception matrix elements like the exception package itself, we're going to create one more class named customer global exception handler. OK, so what this going to do is this is the core handler class. It will handle all the exceptions, whatever we want to handle in our application so we can keep adding all the methods inside this class for what are the exceptions we need to handle globally. So we're going to create this class and extend it to respond to an exceptional handler. OK, response to the exception handler is the core class, which will have the details about all these. It will have the methods for handling the fuel. Are the important exceptions OK? Mainly related to the services. OK, so if you see here, you're also going to annotate disrespect to class with the controller advice. OK, so that can be applied to a wide range of controllers could continue that. This will apply means like we can define the Global Code of Global Error Handling's custom handler. Right. Whatever we are defining that can be applied to a wide range of controllers using controller advice. So that's the reason we're going to annotate our custom global exceptional handler class with the controller controller advice. And next, we'll move on to implementing a handbell method argument not valid. So there steps to zero one. We know that method are not really the exception we have seen. OK, so it's a common method will be there in the response, the exception handler. So we're going to implement this method. And then what about the existing method? OK, from Lesperance into the exception handler and then we're going to test the quality of the service with the same things. What we have done in step one, which is first name one character, and then use a name with them the string and then modify their response. So we should get our custom response, whatever we have defined with the date message and then other details. And also we should get the story before another bad request. So we are going to perform all these things in this customer. One exception handler step now. So let's go ahead and then implement that now. So we'll go for it and then implement the same thing. We'll start with creating a lot of customer details. Plus they come back. So we are know now. So it'll go for exceptions package, so know exceptions. Currently we have used this exception and use a not from exception, these details which we have implemented as part of response dataset, an exception, which means like if I remember in our response status exception, you can see it here. Right. So during this implementation, during this section implementation, we have defined these error messages. OK, so now whatever. We are defining the global exceptional handlers. Right. So we should ensure that both like we are not colliding with the response status exception, the letter, the exception handling and our global exceptional handler. OK, in this project particularly, it's a good practice that, as I said in response, status, exception, conclusion section also that we can use both things, which means that global exceptional handlers using controller advice and also response status exception, which has been included as part of spring fire. Both things we can use it. But one thing we need to ensure is that whatever response status exception is handling those exceptions, we should not be finding other notable exception handler. And whatever global exception Handler is handling the exceptions, we should ensure that those were not handled by this one status exception. So which means like there should not be any confusion state for the system to decide which one it should use. So we should have. Carefully, so we are doing that now, and that's a good thing, right, which means that we are going to learn a lot of stuff here. So now go to new and then create a class. And are exceptions seeing custom error details? Right. So this is our custom details class and. We can just give the message messages quiet. Simple cost. Custom. Her details being OK, so just we are defining this and then we'll define our three variables. So one is a private bit and then we'll define it as our timestamp. Right. So the second is private string and then message whatever we want to provide, OK? And the next one is private string and then other details. Whatever we want to report are we can even see a message, too. So this is a generic message and this is error message. So I'll say the details. OK, that looks good. OK, so now we have defined our variables, right? So now we'll create our field constructor. OK, so let me create the concept of using fuels and then generate the constructor. OK, so next is so this one. Let's import this data in Java util date. OK, so that's good. And then also generate the constructors so to get us right. So select get us and then generated. So now we'll see these as getters and. This is thrill's constructor and then let's see if this OK. So now we have our custom error details class created. So now we'll move on to creating our custom exception, custom global exception. Handler. OK, so. So let's create that now, so I'm in the exceptions package and we are seeing classers. Custom. Global. Exception handler. OK, so we are creating a new class custom global exception handler and this class, what we are going to do is let me make it bigger. Yeah, so it should. Extends right response and the exception handler, slow response entity, exception handler. OK, so and then import this one. We should we could know, so now if this custom global exception handler should be applicable to all the controllers. So what we need to do so we need to add the. Controller advice. Right, so let's import that package, too. So now this was discussed and global exception handler will be applicable to all the controllers, whatever will define the code. Yet either it is exception, handling include or whatever the code. OK, whenever we are annotated with controller advice, then it's globally applicable to all the controllers. OK, so now we will go ahead and then override one method. OK, so first we like the method name here. My third argument. Third argument, not valid exception like this one we are going to handle here, so let's go response and the exception handler ones and then see what is present inside that. OK, so. So what we'll do is we will say. Response. Entity exception handler. Right. So let me open this, OK, so a convenient win this class, OK, this one. So if you see here. In this class, we need to go to the if you see in detail, OK, so that it's the exception handler for all of these exceptions has to be a request method, not supported his GTP media type not supported. OK, not acceptable media type, missing part, variable exception, missing cymotrichous, parameter exception. So like this we can see lots of exceptions which can be handled using response and the exception handler class. So in this our thing is method argument, not valid exception. So if you see here, it's equal in method will be defined in this response and to the exception handler. So let's go there. OK. So if you see here, so this is for the Questors GDP hand initiative request method not supported in the same way we can search for a method argument not valid. OK, so see here it is. OK, so custommade the response fair method argument not valid exception. So we are going to take this method and then implement it the way it is required for us. OK, so we'll copy this method, OK. And then use it in our custom global exception handler thing. OK, so what I'll say is like control v OK. And then I'll remove these things for whatever the written moonlighted. The weight is required for us. OK, so. If you see here, handle method argument, not valid, right? So what we're going to do is we are going to override this existing one. So I'll. All right. Right. So now what I will do is I we have something called the customer details. Right. Using this will set the details, whatever we need for this list. But the exception, method, argument, not valid exception. Whatever the message we want to send. We will send by our being, OK. So I will define our being here. OK, a customer, other retail sales customer I love details is a call to new customer. Other details. Right. And. So inside this, we have three parameters, OK? So one is a bit messy and then other details. So the first one is dead, right? So I'll see. You bet. In the same way, the second message, so I will say this as a name, whatever we want to argue, OK, so far, no, I'll just give that it is coming from Matara argument, not valid exception. This is just for our testing. Right. So I say. From my third argument is not valid exception, OK, in global exception, handler, OK, detail Zilkha shortcut for us, OK. So now and the other one is the third one that also is trending. Right. So what we'll do is we'll bring this down here, OK. So and here audiences will get something from our exception. Right. We have metadata argument, not valid exception. So from here, we'll try to get some better details. Why? Because our third parameter here is error detail, some additional information about our error rate. So I'll see you next, Dot. OK, so whatever we want, we can get it, OK? So I can say get localized message, whatever the string type me how we can get those things so I get localized message or get message so we can get. So I'll try to get some message here. OK. So initially we'll change it and then implement something else later. OK. So now we have a word. Customer details to define. OK. So now we need to return the response entity to this. OK, so let's return the. Response entity, right, and. What are we going to return this customer details, right, so customer header details and also our history status. OK, so I'll see EDP status that bad request. OK, so I'll send that bad request. So. I can see the object here, so this should. Konsta response entity, right? So I need to say, New York, we should be good, OK? I can even put to death that. OK, this should be good. So now let me save it, OK? So if you see what we have done is we want to have a response to the exception handler class. So why are you destroying error. So Jabor, you still get little input, OK? OK, let me say it, OK? No errors, we should be good. Yeah, so what we have done is we went to the response and to the exception handler class and then we tried to find our Matara argument, not valid exception, related method here, and then copied that method to our custom global exception handler, our class, whatever we are defining here. And then we have already the existing method handle that argument not valid. OK, we annotated it with. All right. So now we ready for that matter, whatever we want, we can write inside this. So what we have written is we have brought our customer details being here and then said the messages inside that. And when we are retaining that customer details information back to our whenever this exception happens, then return these things. We are saying, OK, so and then you're also sending the status should be status, that request. OK, so this completes the implementation of method argument, not valid exception, handling using custom global exception handler, which extends the response into the exception handler. So now we'll go to the postman and then test it. OK, so this is the thing. And if you see your username is empty and first name is. So let me send it, OK? Calm down. So if you see statuses 400 bad reckless timestamped, we have got a message. So I have a message from metadata and not valid, exceptional global exception handler. I have defined it without it and other details you can see validation failed for I have said the exception that get message right. So using the exception. But let me say it. You have got the validation feel for argument in public and then you have got all the details. OK, it said was rejected in the first name rejected. You have got some information which is good. OK, so this way, whatever we want, we can define another custom global exception handler and then handle the methods, whatever we want to handle, which means like whatever the exceptions we want to handle, we can handle. So this is what we have done in this section. So in this lecture, in the next lecture, we are going to also work on another method in the same pattern so that we get a little more experience on implementing, using less brons and with the exception handler. So if you reiterate what we have done just one more time, that we have created a customer details class and then implemented messager, other details inside that and with the exception layer itself, same exception layer itself, we have also implemented custom global exception handler and then we have extended it with the response and with the exception handler. We have annotated it with controller advice and then we have implemented a handler method admin, not valuable, copying it from response to the exception handler. And then we have overloaded the existing method and then implemented it with the message whatever we feel is good for our organization. And then we have to start with the postmen and which confirmed that. Our customers are just coming out expecting the global exception handler when we implement the global exception handler
