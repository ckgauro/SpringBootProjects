### Step 14. Step-00: Introduction to Build RESTful APIs with JPA .md
Welcome back.  In this section, we are going to understand and implement restful place using spring data to appear  and head to database.  So in this course, as a first thing itself, we are going to go ahead and implemented lustfully using  HESTA database and then spring data dipu for the fact that if we implement a full time project and then  apply all the springboard features to it, then it is going to look like 100 percent full time.  But if you try to create any of the projects with static that the lists are the maps and then try to  implement for every section.  If you try to implement one one project, what happens at the end is like we need to again collect all  these things together, then we are implementing as a student on our systems.  So here the approach taken is very clear that you can just check out this project with all the branches  to your local.  And then whenever you have a doubt on any of the section example, you are implementing internationalization  in your local system.  OK, for your respective organization.  So you can check out the international branch from this project and then just see what are the changes  from that, what is the local news and what are what we have implemented then?  What what is the resource management and sourcing the internationalization.  So like this you can go and then see there and then immediately you can implement it to your area.  And moreover, the whole idea is to provide a complete Real-Time implementation style with a realtime  project so that citizen, even at the early stages of this course itself, we are trying to introduce  the good concepts of spring data and then has two databases.  So moving very quickly and then very slowly understand and then implement this project as this is the  starting of discourse.  So we are going to take enough time to implement this in a very clear manner, very descriptive manner.  So if you see the steps, we understand that now.  So from implementation steps perspective, we will do the introduction first.  What we are going to bring in, for instance.  So we are going to build this whole project in place, 214 steps.  And what we're going to build, we are going to do the introduction and then we will add the necessary  dependencies in the Brahmbhatt semolina stepto, which is nothing but spring data, and then has two  databases.  Right.  And then we maunder application the properties and our basic properties which are required in our step  project.  Okay, so we're going to do those things then we want to create that interim step for.  So then we are going to create a user entity.  We also need to understand the entity annotation and then what is it.  OK, so we are going to discuss about it in detail in the same way we are going to annotate our entity  with the table.  So we are going to understand about the table in addition to then we more into the user entity by defining  the variables are feelings and then getters and setters.  So that's the standard stuff.  Then in the step three, we are going to understand and then implement changes to host a database in  the sense what it has to database, how you can access, where to control and the browser and how we  are going to populate the data using better data scale, which you are going to use here, and which  we are going to put it in the class part, OK, which is nothing but swordsmen resources, where we  will put this data that the school and then slide the traditional data the and then ensure that the  data gets populated in the entity that we have created.  All those things we'll see in the Stupefy.  Then we want to create the repository.  So we'll extend that repository to create a repository so and will understand about the repository annotation  in detail.  Then move want to start implementing other services?  So what we have done here is like instead of going to the controller earlier, we have also pushed for  initial section, which is nothing but DGP introductory section.  We have our support service layer and then calling the methods in from service to the controller layer  just to show the standard, OK, even we can put the implementation in the interface, all those things  in the service layer, but we just basically put the service layer with one cluster, OK, service class.  So we're going to understand about service layers, a direct service, annotation and control our lives,  lost control, annotation, and then implemented that on with this method.  And we also the postman, this client here.  And using that, we're going to get our users less free service.  From then on, we want to start creating the other methods.  Right.  So we will not stop by just creating some great method metadata, only just a post method.  OK, so who get that post put and then delete?  All my thoughts will create here and then understand them in detail and then implement.  So we're going to create a create using the postman plus mapping and then we're going to understand  about post mapping and needed and we'll implement that usability in both service layer and then call  that in the control that they're using the get mapping.  They need more update usability where the user put mapping so they'll understand and then implement  mapping on how that will be Idy method.  So then we want to delete user by the method and use that delete mapping annotation.  So finally, as we have done whatever we have seen on the level, whether it is that all users are as  target user usability or a little by using the different methods available like findability, find the  same user.  OK, so like this we have the methods by default experts for standard methods and then we will use it.  But in the step that we are going to take to the next level, which means we are going to add a method  in our repository interface, which is nothing but user interface for getting the user by username.  So we will implement that method in our user interface and then will go ahead and get user by user matter.  So this is just an introductory implementations of TPA.  So when we are doing the duplicate, I think we can go in detail in implementing the query and then  with the different different stuff available from the positive perspective, we can implement multiple  methods in multiple formats in a repository like query with network query or deprecatory, all these  things we can implement.  But right now it's an introduction stating that it's a simple method like a fine by user name will be  implementing in a repository interface for use a repository.  Right.  So then we want to finally get comit pushing them much.  So we come core to that local branch which we have created for dippie, and then they'll push that same  details to the remote branch for this one.  OK, and then also muddiness changes for the local master and then again push that to the remote GitHub  repo.  So that's we have done it will be in step 14.  But the important thing here is local, whatever we do here.  So first five or six sections, we are trying to do everything with respect to get in our command line  so that we get close to the command line.  And then when we are doing it for other sections after five to six sections, again, here's the idea.  And then also expanding the idea for another five to six sections so that we have the hands on both  the command line and also the.  Heidi, so far, every section, whatever we implement, we'll have the detail, we ask for steps.  Let's see them here, OK?  So federal building this full services with dippie.  We have the detailed steps outlined in each step.  What we are going to do, if you see as an example, step one, you can see here that we are going to  create user reports to users, get all users with post with a get for users context.  So like this for each step, what we are going to do, it will be our client, like in step three,  step forward, step five.  So it is like all these details will be available for download from cost perspective so that if we have  any like if you are if you have received anything information from your perspective, we can always  rewind and see them are in addition, we can also reference the same things in our continuous running  notes perspective.  Right.  So we can see in each step what we are going to do.  And a very detailed manner.  Example, if you see implemented user by Metaldyne service and controller, as you say, that create  that usability method inside this layer and discuss appropriate and type optional object here.  Right.  So and this optional object will be continuing this over a period for almost 10 sections until we go  further swagga implementation and then show in the Swagga implementation, like how this, instead of  basically retaining user object, will return the user optional object.  Due to that, what our leaders will face from the compliance perspective, and then we will convert  it, but we will introduce the things here in such a way that we will learn by examples.  So that's something and get into the detailed steps.  We can also see here the controller and in control that layer.  What I am going to do is very clear, which is nothing.  But I'm going to implement a user usability method and then add the pathway level annotation for the  part variable which you are sending it, and then annotate the method with the get mapping.  And what I'm going to use is user slash idee.  And then I'll go to the postman and then create a request and then post it like this.  Right.  So everything is very detailed in step perspective so that you will get a complete picture.  So I'll see you in the next lecture with step one implementation.  