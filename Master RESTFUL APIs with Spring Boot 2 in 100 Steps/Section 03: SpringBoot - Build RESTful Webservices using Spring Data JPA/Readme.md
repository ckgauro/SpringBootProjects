### Step 14. Step-00: Introduction to Build RESTful APIs with JPA.md
Welcome back.

In this section, we are going to understand and implement restful place using spring data to appear

and head to database.

So in this course, as a first thing itself, we are going to go ahead and implemented lustfully using

HESTA database and then spring data dipu for the fact that if we implement a full time project and then

apply all the springboard features to it, then it is going to look like 100 percent full time.

But if you try to create any of the projects with static that the lists are the maps and then try to

implement for every section.

If you try to implement one one project, what happens at the end is like we need to again collect all

these things together, then we are implementing as a student on our systems.

So here the approach taken is very clear that you can just check out this project with all the branches

to your local.

And then whenever you have a doubt on any of the section example, you are implementing internationalization

in your local system.

OK, for your respective organization.

So you can check out the international branch from this project and then just see what are the changes

from that, what is the local news and what are what we have implemented then?

What what is the resource management and sourcing the internationalization.

So like this you can go and then see there and then immediately you can implement it to your area.

And moreover, the whole idea is to provide a complete Real-Time implementation style with a realtime

project so that citizen, even at the early stages of this course itself, we are trying to introduce

the good concepts of spring data and then has two databases.

So moving very quickly and then very slowly understand and then implement this project as this is the

starting of discourse.

So we are going to take enough time to implement this in a very clear manner, very descriptive manner.

So if you see the steps, we understand that now.

So from implementation steps perspective, we will do the introduction first.

What we are going to bring in, for instance.

So we are going to build this whole project in place, 214 steps.

And what we're going to build, we are going to do the introduction and then we will add the necessary

dependencies in the Brahmbhatt semolina stepto, which is nothing but spring data, and then has two

databases.

Right.

And then we maunder application the properties and our basic properties which are required in our step

project.

Okay, so we're going to do those things then we want to create that interim step for.

So then we are going to create a user entity.

We also need to understand the entity annotation and then what is it.

OK, so we are going to discuss about it in detail in the same way we are going to annotate our entity

with the table.

So we are going to understand about the table in addition to then we more into the user entity by defining

the variables are feelings and then getters and setters.

So that's the standard stuff.

Then in the step three, we are going to understand and then implement changes to host a database in

the sense what it has to database, how you can access, where to control and the browser and how we

are going to populate the data using better data scale, which you are going to use here, and which

we are going to put it in the class part, OK, which is nothing but swordsmen resources, where we

will put this data that the school and then slide the traditional data the and then ensure that the

data gets populated in the entity that we have created.

All those things we'll see in the Stupefy.

Then we want to create the repository.

So we'll extend that repository to create a repository so and will understand about the repository annotation

in detail.

Then move want to start implementing other services?

So what we have done here is like instead of going to the controller earlier, we have also pushed for

initial section, which is nothing but DGP introductory section.

We have our support service layer and then calling the methods in from service to the controller layer

just to show the standard, OK, even we can put the implementation in the interface, all those things

in the service layer, but we just basically put the service layer with one cluster, OK, service class.

So we're going to understand about service layers, a direct service, annotation and control our lives,

lost control, annotation, and then implemented that on with this method.

And we also the postman, this client here.

And using that, we're going to get our users less free service.

From then on, we want to start creating the other methods.

Right.

So we will not stop by just creating some great method metadata, only just a post method.

OK, so who get that post put and then delete?

All my thoughts will create here and then understand them in detail and then implement.

So we're going to create a create using the postman plus mapping and then we're going to understand

about post mapping and needed and we'll implement that usability in both service layer and then call

that in the control that they're using the get mapping.

They need more update usability where the user put mapping so they'll understand and then implement

mapping on how that will be Idy method.

So then we want to delete user by the method and use that delete mapping annotation.

So finally, as we have done whatever we have seen on the level, whether it is that all users are as

target user usability or a little by using the different methods available like findability, find the

same user.

OK, so like this we have the methods by default experts for standard methods and then we will use it.

But in the step that we are going to take to the next level, which means we are going to add a method

in our repository interface, which is nothing but user interface for getting the user by username.

So we will implement that method in our user interface and then will go ahead and get user by user matter.

So this is just an introductory implementations of TPA.

So when we are doing the duplicate, I think we can go in detail in implementing the query and then

with the different different stuff available from the positive perspective, we can implement multiple

methods in multiple formats in a repository like query with network query or deprecatory, all these

things we can implement.

But right now it's an introduction stating that it's a simple method like a fine by user name will be

implementing in a repository interface for use a repository.

Right.

So then we want to finally get comit pushing them much.

So we come core to that local branch which we have created for dippie, and then they'll push that same

details to the remote branch for this one.

OK, and then also muddiness changes for the local master and then again push that to the remote GitHub

repo.

So that's we have done it will be in step 14.

But the important thing here is local, whatever we do here.

So first five or six sections, we are trying to do everything with respect to get in our command line

so that we get close to the command line.

And then when we are doing it for other sections after five to six sections, again, here's the idea.

And then also expanding the idea for another five to six sections so that we have the hands on both

the command line and also the.

Heidi, so far, every section, whatever we implement, we'll have the detail, we ask for steps.

Let's see them here, OK?

So federal building this full services with dippie.

We have the detailed steps outlined in each step.

What we are going to do, if you see as an example, step one, you can see here that we are going to

create user reports to users, get all users with post with a get for users context.

So like this for each step, what we are going to do, it will be our client, like in step three,

step forward, step five.

So it is like all these details will be available for download from cost perspective so that if we have

any like if you are if you have received anything information from your perspective, we can always

rewind and see them are in addition, we can also reference the same things in our continuous running

notes perspective.

Right.

So we can see in each step what we are going to do.

And a very detailed manner.

Example, if you see implemented user by Metaldyne service and controller, as you say, that create

that usability method inside this layer and discuss appropriate and type optional object here.

Right.

So and this optional object will be continuing this over a period for almost 10 sections until we go

further swagga implementation and then show in the Swagga implementation, like how this, instead of

basically retaining user object, will return the user optional object.

Due to that, what our leaders will face from the compliance perspective, and then we will convert

it, but we will introduce the things here in such a way that we will learn by examples.

So that's something and get into the detailed steps.

We can also see here the controller and in control that layer.

What I am going to do is very clear, which is nothing.

But I'm going to implement a user usability method and then add the pathway level annotation for the

part variable which you are sending it, and then annotate the method with the get mapping.

And what I'm going to use is user slash idee.

And then I'll go to the postman and then create a request and then post it like this.

Right.

So everything is very detailed in step perspective so that you will get a complete picture.

So I'll see you in the next lecture with step one implementation.

So until then, bye bye.

Thank you.


### Step 15. Step-01: Usecase Introduction.md
Welcome back.

In this lecture, we are going to look into the useless introduction, so we're going to build a simple

user management service using springboard data JPA springboard.

So to do so, what are methods employed in Ben Wartell resources and what we are going to look into

in this introductory section.

So if you see if you want to build a simple user management service, the Belardi.

Methods we need to implement.

So the primary thing is we need to implement the user method and we need to retrieve all users from

the database so we can say that to get all users right in the same way that we can retrieve the.

There was no primary.

Is nothing, but usually so in the same way, we can also update the universe using a producer method

and fertility, what else we can do with the user?

In addition, these are the default methods.

So in addition, we can find additional things in our repository interface and then add additional methods

so that be something like that user by username, arget user by last name or get user by email.

So like this we can implement multiple methods and then convert it to the services.

So if you see here for a create user method, so we are going to use the post and the resource is going

to be slash users.

Right.

So the context, what is going to be slash users in the same way?

If you say get that all users name itself says that it's a good method.

So we'll say get right and it's context.

We are saying that we need all users.

So we'll see slash users right the same way, get users by idee.

So to do so, what we'll do is it's a great method and then its context is going to be slash user slash

and a part will be named idee.

So once we pass the slash, the number of that respect the user, then we should be able to retrieve

that user from the database.

So to do the upgrade user.

So we need to use the method named put and input.

We're going to use user slash.

We're saying update user by idee.

OK, so we have two options to do this.

One is just send a complete request.

Body and blood are also in addition to the body in the body itself.

Send the idea and then blow it up.

You can also do it by sending the idea.

So we'll send it back Heidi.

Right.

So in the same way, the lead user by Idy.

So we'll use the method named delete and user slash.

Heidi.

Right, so.

Now get user by user name, so as the name suggests, the method is going to be good and.

Well, we need to the context is going to be slashing users, slash, if I say user name here.

So the context gets a confusion, but we have user slash user name get and then get user by I.B. So

definitely we need to change the context here.

Stating by user name.

Right.

So now there is no confusion because the user by user name says she was slashed by user name and then

provide the user name another parameter and then we will be able to get that.

So this completes comments like these are the things we are going to build in our current BASIX Big

Data display application, which is nothing.

But we are building the user management service.

So we are going to work on a series of steps close to 12 to 15 steps to implement all these methods

step by step and also provide additional information that we're going to build these based methods.

And then we are not going to apply any exception handling or has to be status quo in response.

All those things we are not going to do in the base implementation.

So once we complete this, 12 steps are 15 steps required to implement all these creating that method.

But all users method all these things.

Then in a separate section, we'll start applying for each method in the sense like for creating user

Wattyl exception handling.

We need to perform.

And also Wartell has to be status quo.

We need to write an example of how to create user.

We know that whenever a user object is created, we need to return to zero one created.

Right.

So how we are going to implement that.

So.

This methods implementation means like this service implemented in all these services implementation

is going to be in one module and then in the next module you'll focus on in the next section will focus

on implementing the TTP status codes, response codes and respect to exception, handling messages and

all those things in the next section.



Until then, bye bye.

Thank you.



### Step 16. Step-02: Verify pom.xml for all Dependencies.md
They come back in this lecture, we're going to verify the dependencies required for a very simple project

which we want to implement.

So the mandatory dependencies we need are Springbroot Starter Spring boot data dippie and then has to database.

In addition, the optional dependencies.

We need our Springbroot Blackpool's.

So this is required for our convenience from development perspective.

In addition, we're also going to create a separate grid, get Jhpiego Asset Management Service based

implementation so that what changes we have performed earlier will be preserved and then for later,

user management service will be under separate branch and then we are building the status quo.

And when exceptions, we are going to work for the user management hyphen status, goaltending exception

handling so that that will be in a different branch.

And then we have a clear separation of what we have done in an incremental manner and we can go back

any time to those respective bluntest to reference the code.

So let's start with the verifying the problem that we have starter web, then data JPA HESTA database

and also go ahead and create the GET branch required for us.

So let's go back to Idy so that you know, and then let me open the public Similac.

So if you see the palm, that example, we have the springboard starter data dippie start up the pools

and then HESTA database.

So we have verified all of our respective dependencies for this project.

So now I want to get perspective here and then in get perspective.

I see we are in the.

Masterbrand Chicot currently, and whatever master and then zero to Hollowell is in sync, which means

for Masted will be able to create new blood.

So this time we are going to use Heidi to do so instead of blowing it way up.

Come online, get comments.

We're going to do it well, Heidi, so 03.

J.P..

User Management Service.

Fan this, so as soon as I can have this brand, well, it will check out this respect to Branch.

OK, so let me continue.

OK, so we are in this branch currently.

So if you see here our enter code, basically zero three deputies are management service branch.

OK, so we can see it here.

So this completes our Verify the Palm that XML and then creating the equal branches and completing all

of our prerequisite sections required for our local project.

OK, so in the next the next step, we're going to update the application that properties with the spring

related properties which are required from history database perspective, are from a scale perspective.

.

Thank you.


### Step 17. Step-03: Update application.properties required for JPA based RESTful Services.md
Welcome back.

In this tape, we are going to update our application that properties with two properties, one is but

surely a psychological two through.

So what this does is like it will provide the calculus in our concern, which means like it is going

to display all the calculus running between the entity.

What we are creating in the back is database using going to be displayed in the.

Counsel, so that we can view what's going on and what is this how the supreme data is working, so

in the same way for the next property used to springboard to not consolidate and ability to do so,

this will allow us to browse the database via browser.

So housing has to continue.

OK, so let's add these things to a Web application.

That property's now.

So we add in the application that property Snowsill will spring dot G.P.A..

Choice is equal to true.

The same way spring not is to not console able to do so, these two properties we have updated in our

application, not properties.



Until then, bye bye.


### Step 18. Step-04-01: Create User Entity - Understand @Entity Annotation.md
Welcome back.

In this lecture, we're going to work on creating a new entity, so as our application is a user management

application, our entity is going to be the user entity.

So as part of that user entity creation, we're going to learn all these things.

So one is a direct entity at the table.

The following annotations, OK, great ideas that are generated value and then a direct column.

In addition, the user entity, we're going to add the following fields idee, user name, first name,

last name, email and then SSN.

SSN is nothing but our Social Security number.

Just a sample.

It's not real SSN, I might guess, and one zero one one zero two, something like that.

But just to have put it, because if I say it's primary key, in addition to that, in any relational

database, we can also add unique constraints.

Right.

So to display or to make everyone understand about the unique constraints and then implementing unique

constraints in entities.

So I have added username one additional unique constraint and as I said, another unique constraint.

So these two things also we are going to make them as unique using the column parameter unique.

So all these things we are going to discuss in our current user identity creation.

So let's go ahead and then create the entity now and then.

So we'll go to our idea and then start creating the entity.

So let's create the entity class now, so we'll see class and we'll create the entities in.

Into this package, OK?

So and then I'll say the last name as user, so we are going to follow production standards for creating

the packages in this project, which means like we have entered into this package, repositories in

repositories, package and controllers and controllers package.

And in addition, we are also going to use the services also here so that any business logic will be

available in the services and in the controllers layer.

We are going to put it as completely history will further discuss in upcoming lectures in detail.

But for now, if we are creating a user entity and we are creating a package under the ServiceSource

entities and then the name of my classes user.

OK.

So this is the one.

So if we talk about entity, right.

So let's understand a little bit about entity before moving on to defining it and then implementing

it.

OK, so entities have nothing but produce the presenting data that can be Parchester to the database.

So in a very high level, an entity represents a pebble stored in the database.

So every instance of an entity represented in a table.

So the entity name defaults to the name of the class.

So if I say a delayed entity and then I need to say got mindshift.

Oh, and then what we need to import that directs persistent entity here.

OK, so now we have imported it so.

Entity name refers to the name of the class, which is nothing but the user, right?

So but even we have an option to declare an entity with a different name using the name parameter.

So if you say a name is equal to a small user, then the name can be defined even as it is a different

name here.

OK, or something else, whatever we want.

OK, so I can say users or whatever I want to define, I can define here.

OK, so but more or less forever identities will suffice for us, so we will use a direct entity.

But just to let you know that we have an option.

So I have explained about the same so we can change its name using the name element inside the entity.

So this completes the entity introduction.

And then in the next lecture we are going to focus on understanding the table.



Until then, bye bye.


### Step 19. Step-04-02: Create User Entity - Understand @Table Annotation.md
Welcome back.

In the previous letter, we have created an entity class and then annotated with the entity and also

discussed about what is an entity and then how entities need to be defined and then how the entity names

can be defined with name, element and all those things.

So in this lecture, we are going to focus on the table annotation.

So let's go back to what I know.

So the table annotation is a great table, and if you see here in most of the cases, the name of the

table in the database and the name of the entity will not be the same.

So sometimes the entity name will be a means like if there is no droppable, then in the database the

entity name will be the table name example.

It will be with Kaplan.

You Smalley's here, but here in current case, if you define so problem here with the name element.

So if you say name is called.

Users are user, whatever we define, this name will be the thing that will be created in our.

Database, so Derek's persistance people so important that that Comanche or in my Mac.

So now if you see a name is a clue user.

So in such cases, like if you don't want the entity name to be the same as inevitable, we can use

this table name editable annotation.

So in addition to PayPal, there is something called the schema.

So there is one more element in this table, which is nothing.

But we can define it as a schema so we can give our schema name here.

So what this does is it will distinguish one set of tables from another.

So we have different applications and then in both applications, we have whatever may be the case.

OK, we have different different tables with the same names in different schemas.

And then we want to use the dual data sources from our respective spring application.

And then we don't need to have any issues.

So schema can be used as a distinguishing factor between the tables one and the other.

So we can see schema and then we can say user management, something like this.

In our case, we are not going to use schema because we are going to use a database which uses the default

to test the deposit schema name.

So we are not using it here, but it's good to explain.

So I have explained it in detail here about using the schema, so.

That's a greater, terrible annotation and finally.

If you do not use the droppable annotation, the name of the entity will be considered as DE.

Name in other respective database, so so I'll see you in the next lecture and bye bye.

Thank you.


### Step 20. Step-04-03: Create User Entity - Define Variables, Getters & Setters.md
Welcome back.

In the previous lectures we have discussed about the great entertainment table annotations, so now

we are going to create our full set variables in our respective entity.

So let's go ahead and do that now.

So our.

First one is private law, Heidi.

So this one, we're going to consider it as our primary in our people.

So we'll also see private string username and you'll also see.

So the reason we are taking multiple instead of doing it with one or two Marable's, we're doing that

with five to six or seven variables is to understand better in from better perspective than we are writing

the data that Ezekial Farishta database and then how it is going to be all those things.

OK, so let me do one thing now.

So it is just me right in the same way.

Will also do will also define private string last name and.

Private.

Private string.

Email.

Revegetating.

Rule.

And then private string SSN, so we have declared the seven variables now, so we'll start with the

first one, OK, which is nothing but the private long idea.

So to.

Tell in depth that this is going to be our primary key, we need to annotated with a direct.

Right.

So when we annotated with a retiree, so dippie makes it as our primary key.

OK, so develop a system that works.

Persistence, Heidi, was important.

Not so.

You should have a primary key which uniquely identifies it.

So a great idea, annotation defines the primary key here so we can generate the identifiers in different

ways, which are specified by a direct generated value annotation.

So if we are here, the generated value so we can autogen the.

Value for this.

I do feel OK in an incremental manner or whatever.

So we'll have other strategies available here for at regenerator value, which is nothing.

But our two people sequence our identity.

So we're going to use the default.

We're not we're not changing anything here or we are not doing anything related to adding strategies

and all those things as we are going with the basic DP application.

I'm just annotating it with the data generated value.

So now moving on to the next one, which is nothing but the username.

Right.

So in our database, if you feel like if you leave it as Defarge like this in our database, the column

name is going to be directly username.

So instead of that, if my database needs a different name or if you have an organization, has database

standards, we're naming convention should be in this manner.

So as our Java code naming variables and then database we're naming conventions will be totally different

in reality.

OK, so if you want to follow those things as per our global standard, so we need to use the annotation

in the red column.

So Comanche's to OK, so import my red column up.

Bacquet So what I do know is a column and the elements it will have is like we can send name.

Right.

And I can see Yuzu underscore name is my column name in the same way if I see you and I can also define

the length of this field.

OK, so this is only applicable for string type.

OK, so and then my Lentulov, my string is going to be not more than 50.

So in the same way I can serve a database.

The main thing is whether it can be nullable and not right.

So I'll see Nullable is false.

And one more element for Aderet column important one is unique.

So defining disrespectful column as unique constraint are not so example of a defined username as unique

constraint.

If you try to or if you try to create a user with the same name again, then it's going to trial and

error.

So for username, we are planning to use it as a unique constraint in the database and also it creates

the index.

I'll show you in the database.

I would God created the unique index with this once we define it as unique.

OK, so now we have the column defined here a the red column name user name is equal to false and then

unique is equal to two.

Right.

So so in the relational database world, if you see a table can have only one primary constraint.

OK, but we can have multiple unique constraints.

So considering that statement.

So what we can do is so we can copy this and then so we can even define the red column for the SSN.

Right.

So let me make it bigger.

OK, and.

And I'll say.

Name is called SSME.

Length is equal to 50 and nullable is equal to false and unique is equal to true.

So we have defined a particular constraint in this table, which is one is SSN and the other is user

name.

And we have one primary key named Ida.

Right.

So let's also define the data column.

And the name is equal to first underscore name.

And Lent is equal to 50 and Nullable is false.

So let's define the same things for the other two there.

Three.

Variables, too.

OK, so I'll see.

So see.

Last underscored me and I'll say e-mail address and I'll say, OK.

All right, so these are the things that we have defined here is a typo, so name.

OK, so this completes the variable rate column annotation.

Definitions like means like discussing about the name Linda Nullable and then unique elements inside

the Aderet column, and then we have applied those things to these variables.

OK, so now what we are going to do is so we need to define it.

No argument.

Constructor, OK, and the constructor.

And also, one more is dippie will not be happy without this argument, constrictor.

So definitely we need to have it.

And one feels constructor and.

Getters and certain soccer fields, constructor is optional and in the same way, bootstrapping is also

optional.

So these things are optional, but no argument.

Constructor and then gittleson sectors are mandatory things.

OK, so let me add those things, OK?

So let's go to source and then.

Dendrite.

Constructor from Superclass, OK, so it's generated now.

So let me remove these things.

OK, so I will copy this.

And then see no argument constructor, right, and will also define the field's constructor and all

those things.

So let me define those things here.

So Sors generate constructor using fields and we have generated the constructor using feel now so we

can cut this and then paste it here in the same way.

Will also defended the getters and setters.

OK, for all the fields.

So we have generated the that doesn't set us now.

So let me take this and then.

Put it here, this is just a comment.

OK, and now two string is also this is an optional look when you want to do troubleshooting and then

enable logging at the cabin level.

So we need this, OK, optional required for I've been logging.

OK, so I can say like this.

OK, so this is an optional thing, ok.

So if required we can do it are if not required we can leave it.

OK.

So what I'll do is like I'll generate it.

OK, so that's fine.

OK.

So we might, it will be useful.

OK so.

And then generate two string.

Right.

And then generate it.

OK, so we have also a generator though to string.

And.

OK, so this completes the creation of the user entity, so let's go back to our.

This one, yeah, step, so if had read what we have done for recreation, so we have discussed it in

lectures about what is a great entity and its element, name, element.

And we also discussed about the table and its name element and also the schema element.

And then we moved on to creating other variables here with its user name, first name, all these things.

And then we also discussed about a great idea, which is nothing but up for debate.

And this field is going to be the primary key and also provided a great generating value for generating

the members of the incrementing the members.

And it has different strategies available.

And we really didn't discuss here.

It goes very in-depth when we start discussing those things.

But it has four strategies which we didn't focus yet, primarily by focusing our little steps when we

are doing deep in depth.

OK, so now in addition, we also discussed about the red column and the column annotation and we have

discussed about its element, namely the nullable and the unique, primarily to focus on the red column

is the unique constraint means like defining any attribute, are any variable as unique in that respect

to table we need to use the unique is equal to two.

And also we have defined the normal construct Bradfield's constructor and also the two string in our

respective entity.

So this completes the integration.

So we'll move on to the next step now.

So we have completed the integration.

Now we need to focus on creating the.

Repository.

OK, so I'll see you in the next lecture and in discussing about the deeper repository.

So until then, bye bye.

Thank you.


### Step 21. Step-05: Understand and Implement changes related to H2 Database.md
Welcome back.

In this lecture, you're going to understand about history, database in history, database related

changes we need to perform for this simple project.

So we're using the history database, which is in-memory database, so in memory database.

So what it is going to happen is like whenever we restart the division right in our Pingrup.

So what happens is we lost all the data.

Whatever is there in that respect to EU database or whenever using the database, if you make some change

in your application and then say that when they were a little bit of a division during that time, also

the entire database will get refreshed, which means like it will grab the table whatever is created

and then it will recreate it.

So which means always the table is going to be empty so we can even pre populate the debate during runtime.

So taboo.

So what we need to do is we need to create the data that is killing our class bots so we can put it

in a our source mean resources.

The filename is data that is cool.

So and then we can add that in such statements about what data need to have and then whenever we save

that.

Project after 10 years or whenever the game gets reloaded during the process, all this means like it

will grab the table and then recreate the table and then it will insert whatever the recordset we have

chosen or put it in the data that will all that is going to be loaded.

So one thing which we need to take in here is about the order.

OK, so we'll see that later.

And another important thing is we need to go going to our application that properties enabled us to

consult so that we can access our heads to console.

And the database eurorail for in-memory database is to remember that DB.

So no, as we have completed the creation of the entity.

So as soon as we start the Springwood app, which is nothing but the American Tomcat.

So what happens?

Is it the entity will try to create the tables means like whatever entity we have created equal will

be created in the HESTA database, which is nothing but the user table with all the columns.

So let's go ahead and do that now.

So we are back in it, you know, so let's right click the project and run this Springboard app, so

let the springboard come up.

Yeah.

So now if you see here, if any existing thing is that it is going to drop drop, they will use that

effect.

This so in the same way, hibernates, sequences, everything.

And then again it will create the table sequence and also the unique constants which we have defined

in our entity, which is nothing but that one for the user name, which we have said unique is equal

to two and the other is the SSN.

Unique is equal to two.

So let's go to the browser and then view the table.

Where to console.

No.

So the has to console you rather lose our local lost 88 to hyphen console.

So and then our other classes are headed to driver Jerry to see where all this will be the populated

and there is no password for that.

So we'll click on Connect and be logged into the hash to console.

If you see here, there is a table named user.

So this is the table which we have created as part of our integration.

So if you click on this, we can see the list of columns which got created automatically.

So whatever the column name field we have mentioned, the e-mail, underscore address, first name,

underscore name, last name, underscore name, role, SSN, user name, all got created, Asperger

details, whatever we have given in our entity.

So if you see here, other than Idy, you can see restante fields were displayed in alphabetical order

E, F and R as you.

So which means whatever the insert statements which we are going to create for disrespect to use a table

means like whatever the data we are planning to populate before going for the further development.

So those things we need to ensure that our insert statement also has the values inside that in this

order I'd email address first, first name, last name, SSN and then username.

So that's the thing.

So.

So let's check let's start from Yuzu, so currently we don't have any data inserted inside this, so

we are getting Nawruz.

OK, so let's go back to your idea and then start working on our next steps.

OK, yes.

Our next step is to create a digital deskilling, swordsmen resources and then insert these three records.

So if you say inserting the user in the values in the first is like whatever the primary key idea.

So I started with one zero one because whenever we are doing creation of users using the postman claimed

what happens there is like a it starts from one.

OK, so if we start with one, two, three, then it will provide.

So I just gave it us one zero one one zero two one zero three here.

OK, so and the second one is as per the alphabetical order, we have email in our browser.

We can see here an email address.

OK, in the same way we have the first name, last name and then rule and then SSN and finally we have

the user user name.

So in the same order, whatever we are seeing here, in the same way we have built our insert command

to use a table.

OK, so we are going to create a direct source, mainly sources of our project, and then copy these

three lines and then put it there.

OK, so let's go back here and then we are in swordsmen resources new and then file and then we can

say the file name is DataDot Ezekial.

Click on Finish.

And we can skip this version.

We can close this we have a terrible place in the world in this respect to mission so that it is trying

to show where are taking place as our default editor.

OK, so I'll try to close this site to close this, and then I will open it open with a text editor

that should suffice for as OK, because we have already created our insert comments here.

OK, so let me see a copy.

OK, and then I will.

Save it.

OK, so now the Tomcat got remarried right now, so let's go back to a Web browser and then let's try

to see Select Start from User.

This will also as soon as when the Damian Lillard had to cancel connection also gets reloaded.

Right.

So this should take us to the login page.

Nokia.

Yes.

OK, so let's click on Connect and then say select start from.

User, so we should see.

Three records.

So one zero one one zero two one zero three.

We have three records in 38 now, and it is populated automatically whenever the division gets reloaded.

So if you see we have completed all of our steps related to HESTA database.

OK, so we understood that his databases are in memory database and then whenever we have made any changes

to the code, it removes the data, which means like if we go ahead and then make any changes.

OK, so example, we can go to our respective user, Dajarra, and then see it and they just some comment

and then say, OK, so what happens at the end is so it tries to reload, but in the process it will

drop the table and then recreate the table.

OK, so at the time the entire table will be dropped and then it will recreate the table and then it

will also load the data into it.

OK, so that's about.

In-memory database, which we are using here, so it also appears that DBE, during that time with data,

we can see that with data if we use the data that Eskil so far that what we have done, we have created

a data that Eskil enforcement resources and then we have inserted three rows inside that, OK.

So as soon as these three insert records will be inserted to the database.

So another important thing which we need to understand, these columns will be created in alphabetical

order in DB except the primary key.

So in such statement, value should be in alphabetical as displayed.

It never has to be so and has to cancel.

You are local or state has to cancel and the database BCU are the best DB.

So this this concludes our answer session about the H2 database.



Until then, bye bye.

Thank you.


### Step 22. Step-06: Create User Repository - @Repository.md
Welcome back.

In this lecture, we are going to discuss about the repository and also create a repository interface.

So we are going to create an interface named user repository, which extends the deepest repository.

And also we are going to annotated with a direct repository.

So these repositories are nothing but we can consider it.

Does it be Avonlea which typically does all the database operations?

OK, so let's go ahead and then create that now.

So let's go back to our idea.

And so far, if you see we have created our application that properties and we also created the user

user entity and we also created that data school.

OK, so now we are going to create a new package.

Under that package, we are going to create interface.

So I'll set a new interface and then I'll also say in which package to get created is Rippa sitarist.

OK, so repositories and what should be the name names.

User repository.

OK, click on Finish.

So now the first thing is this is a repository, right, so that we need to have an idea and the next

is we are going to extend it with deeper repository.

So extends J-P.

Repository, right?

And we need to provide our identity as yuzu and entities primary years long, right?

So that is the thing.

And we also need to import our user entity here.

Right.

So Comanche, after all.

And then we are going to import over into this user.

Right.

So now we have extended the user repository interface with the repository.

In addition, we also need to annotate it as a repository and command shift or to import the package.

So.

This and then save it.

So this completes the creation of the user repository for us, so which means now we can move on to

a service layer of creating the application.

So we have completed creating the entities layer and then repositories layer.

OK, so now we go ahead and then implement the service layer, OK?

And then finally we will implement the controller layer.

OK, so let's go ahead and then implement this obviously now in our next lecture so I can see you in

the next lecture.

Until then, bye bye.

Thank you.


### Step 23. Step-07: Implement getAllUsers RESTful Service - @Service, @RestController.md
Welcome back.

In this step, we are going to implement guitar users method, so to do so we need to create a service

layer and also a control layer.

So for service layer, we are going to create a user service class in services package and then we are

going to annotate it with a direct service and then we are going to auto where the user repository in

the services layer.

So this concludes our services section after creating the guitar users method inside that.

So these are the things we are going to perform another service layer in the CMB, in the controller

layer, we are going to create a user controller class and then annotate that respective class with

a direct rest controller, which is nothing.

But it is going to the vegetable layer, which means like from browsers are from less claims.

We will be able to communicate with our other services using this layer.

And then we are also going to operate the user service, which we have created here in the controller

user controller.

And then we are going to create a method that will use this method and then annotate it with.

It direct get mapping, so we are going to create a great kidnapping, forget I'll use this method which

we are going to create in comptrollers user control class.

So this is what we are going to do in this lecture.

So primarily we can directly create the controller and then we can leave the service layer.

But to follow the standard design patterns from coding perspective and all the we need to have the service

layer in the service layer we can have in a number of business logics can be implemented.

So but we cannot implement business logic.

Seems like it's not a standard practice to implement business logic since the controller layer because

we have that has to be affronting in that area so we can define any number of methods and then have

multiple objects in the service layer.

So to follow standard design patterns.

So we are following those things to ensure that we are in compliance, like we can use this product

as a template.

One more thing is we can even create the interface in service layer and then create the implementation

class and then create all these things in the implementation class, too.

But it becomes only longer and longer for us.

So that's the reason we are just debating or taking a minimum level shortcut that we are just creating

a service class.

We are not creating any interface class and then implement it in class.

We are just creating only one class user service class in the service layer.

So let's go ahead and then do that now.

So in service layer, our first steps are to create a user service class annotated with a direct service

and then AutoReader user repository and then go ahead and then implement the GETÚLIO this method.

So let's go back to our idea and click on our main package, rest services, and then I'll sit class.

And now we need to create a package named.

Services, right, and in services we are creating, you use that service, OK, and then I click on

Finish.

So now we have the user service.

So this is it.

Service.

OK, so which means I'm going to annotated with a direct service and then I'm going to see a command

shift or which means I'm going to import that respectable package.

So next stop all the way to the user repository.

Right.

So we'll say private user repository, user repository.

And we are going to come out of code to import our user repository and then we'll see a direct APPLEWHITE.

So which means we are going to out of a shift or to import part of a package.

So now we have automate the user repository.

So now let's go ahead and create the get all users method in here, OK.

So to create a gate all users method, we can say that when we are retrieving all users we can consider

that as a list.

Right.

So public and our prototype is going to be released and what type of things we are going to return,

which is nothing but our users.

Right.

So we need to add our user entity here and we say get our users use my method name so it will not have

any input parameters.

So I leave it as it is and then say enter.

So let me put first to the user entity here and also Java.

You can list.

OK, so we have input both the gelatin list and also the user entity.

Right.

So now let's go here and then create the minutes like list all the users to do so.

What we need to do is user repository DOT.

JPA provides direct

methods for all users, which is nothing but find all.

Is the metadata repository, we can see it here, see the repository and then find out, OK, returns,

all instances of the type, so it returns all entities.

Right.

So find all so we can see we can return the SIM because our return type is also listing the end user.

So now this completes the let's save this, OK?

And then we don't have any issues here, OK, from the log perspective.

So we have implemented the data with this method, another service layer, so that it can type a list

and then use it and then get all users and then the repository that find all that and the same thing.

So this will return to our list of users present in my HESTA database.

So this completes the service layer creation, by the way, just to let you know that we are not implementing

currently any of the validations or any of the exception handling or has to be status codes in return.

All those things, once we complete the best project with all the methods, which is like get all users

and then create user update user, get user by user name, get user by idea and also delete user.

Once we implement all these methods and then get a hold or comment on those methods, then we will extend

our project to implement exception.

Handling for every method and also implement has to be status quo.

Just like 200 or to zero one created are four zero for when I try to find a user, get user by username

and get user by idea.

So if I try to find a user, I can throw the folder for the user is not present.

So like that are custom messages.

OK, so now we want to create another controller as we completed our step up for creating the service

so that the users method will move on to creating a better controller.

Now, OK, so let's go to our main package and then send a new class in the package.

Names, not controllers, and we are going to create user controller.

OK, and then click on Finish.

So now if you're seeing the controllers, so we need to have the controller annotator tell Spring that

what type of controller is this?

So we'll see that list controller.

Right.

And then come on to total import our controller package right now and then know what we need to do is

we need to automate the service.

Right.

So automated user service.

So I'll say.

Bloviate, use a service, use a service, OK, and then I'm going to automated that and then I'll take

a much of total input, the respectable.

Package.

OK, so now we are told that.

Use that, so let's implement the guitar users method here, OK, so our guitar users method is going

to be public laced and user, so it is going to list a list of users.

Right.

So and then I'll say guitar users so it doesn't have any input parameters.

So I commend you for to import that into this user and also Jabuti list.

OK, so we have input both and then we are going to return user service, start get all users.

Right.

And then it.

So here we are clear.

So we have defined a method which will return all the users.

OK, so we have called the user service DOT, get all users matter, whatever we have created, just

no disrespect to matter.

And this respective method will call the user repository DOT.

Find out.

So we will bring the data from our database.

OK, so now what we need to do is we need to annotated with a get mapping, which means we need to give

the whole city bilayer for that.

OK, so I said get mapping and we need to provide that.

You are a control command yiftah and then I'll slash users.

Right.

So.

And then see.

So this completes our control part, which is nothing but whatever we need to define in our less control

effort to use this method, we have completed it.

So in the next lecture, what we are going to do is we are going to test it using that Posman line.

So we are going to all create a request in a lot of Posman clients and then test these things.



Until then, bye bye.

Thank you.


### Step 24. Step-08: Test getAllUsers RESTful Service - Using REST Client POSTMAN.md
Welcome back.

In this tape, we are going to, first of all, tell you this service, the service using the post less

claimed.

OK, so we can download and install the postman using this, you get pressmen dot com so we can see

it here so we can go here and then download our last client and then install on our desktops.

So if you come back here, so once we download and install it, we can create a collection in our client

and then we can create a request under that collection so that we can create a collection name displaying

the building blocks so that what happens is like we'll have that for disrespect to project.

We have all our requests at one place.

OK, let's go ahead and do that now.

And we're going to create a request after that, which is get users so far that we are going to use

the Metrojet and then you press local 880 slash users, whatever we have given in our users, whatever

we have given in our controller.

OK, so let's go back to our postman.

So this is our postman.

Application.

So what we'll do is we'll go to new here and then see collection, OK?

So and then I'll say Springwood building blocks.

OK, so I can see that description.

Other services.

Built as part of.

Building blocks project, OK?

And then I'll say cleared.

So now I have the Springwood building blocks here so I can see you, which means like we can even search

our respective collection.

OK, so inside this, what I'll do is I'll try to create a new request, answer and request.

Right.

So in my request, names get all users right, but all users and then settle here.

OK, so I click on this and then what we need to provide here is our you are right.

So who's to be localhost.

And then I have existing things here.

The user's right and then I'll click on sale.

So now I have one request in our Springwood building blocks, which is what all users let's go ahead

and test that and also for elderly consent.

So we need to get a response of three users, which we have inserted into our history database, which

is nothing but one zero one one zero two one zero three.

OK, so if you see here, we got the idea, user name, first name, last name, email and then SSN.

So all the attributes we have got it.

OK, so but one thing important here is we can even like one of the important things we can do in springwater

is like, oh, filtering.

Right.

So which means usually you really don't want to share the SSN for a few services.

OK.

So you can filter and then exclude the SSN.

So those type of things.

OK, so we will do those things in the next part of the course, which means like the word itself,

the project itself says that spoonbill building blocks.

Right.

So which means like as we build the next blocks of this project for Springboard, we'll also ensure

that we will filter a few of the attributes and then will only send a few respected attributes for few

services, which means like I use that name, first name, last name, email, and then role will be

sufficient for us, like for some clients.

So we really don't need to send our SSN, which is this.

It is a secure one.

So like this.

So that's the reason instead of using one of the variables are two attributes, OK, are two elements.

We have user multiple elements to implement a lot of things in the upcoming lectures and then sections.

So now we have successfully tested the button users using the postman.



Until then, bye bye.

Thank you.


### Step 25. Step-09: Implement createUser RESTful Service - @PostMapping.md
Welcome back.

In this lecture, we are going to implement the create user method so that when we submit a request

with some of the ideas and details with create user, whatever the attributes it is required, and then

when we post that data, the user gets created in the database.

OK, so let's go ahead and do that now.

So in the service layer, we are going to implement the create user method and in control earlier,

we are going to implement to create user matter and also accept the input as the input, whatever we

are sending via post right from this client.

We are going to accept it with a direct request for the annotation and then we are going to monitor

the entire create user matter with a direct post mapping annotation.

And then once this is completed, will go to our postman and then we will verify at best our create

user service.

Right.

Let's full service enforcement best client.

So we're going to create a request for clear to user and we are going to create the body and then select

the right area and then content papers, Jason, and then method as post and then test using Bowsman.

OK, so we are going to do all these things in this lecture.

So first, let's go back to our idea.

You know, so we are in our idea, you know, so we need to go to our service layer.

So nothing but user service, OK?

So what we have done for now, we have created the Gaitonde users method next year, create a user method

and create user.

What we are going to do is.

Public.

And what we are going to return for now, we are not returning any fancy messages of the status quo,

like two zero one user created or like a user with user pod, etc. So we are just going to return whatever

the user created.

The same user we are going to create as part of this base implementation.

So the return type is going to be user and then we are going method is create user.

OK, so.

And create user, we are going to say what what is the input we are going to get is the request body,

request body?

What type of input?

This is user user.

Right.

So let me.

See, controlled Comanche, left or right, and only we have need to define the return type, right,

so return yuzu repository DOT will have a method by default, which is nothing but Sèvres in the NTD

user entity.

Right.

So and then we should be good.

So what happens here is from the controller it will send when we are calling this creative's, that

method, it will send the user entity, user body.

Right.

Whatever the thing which we are posting there is clean.

So the same thing, user repository, that same method will submit to the database.

OK, so that is the create user method which we have defined in the service layer.

Right.

So let's go back now to the.

Control earlier.

Right, so in the control earlier.

So what we are going to do is sort of, as we say, create a user so you can say that what we are going

to do, one is request body.

Right.

And the other is post mapping three things.

OK, so create user matter.

And we are going to introduce that a direct request by the annotation.

And we are also going to introduce the voice mapping annotation now.

OK, so first let's create the method so public and what we are going to retain is user right.

And the method name we can create user.

Right.

And now the input type is a direct request body and the user user and command shift or OK.

So now the request bodies are important.

So now what we are going to do is.

Later, we are going to call the producer method, which we have defined in our service.

So I'll say user service, dot create user right and user and.

Use said, OK, and that's all, so now we are going to create a user, the input we are going to get

in the request body in the rest services request various user type.

OK, so and then we are going to save that using the create user matter, which we have defined in our

user service.

So we have completely clear ideas that matter and a direct request for the annotation.

So next year to define our make it as a service using post mapping.

Right.

Post mapping.

And we are going to say does users Comanche both the post mapping and then save it?

OK, so this completes our creation of the use user method in both our service layer and also the controller

layer.

OK, so now we'll go back to our client Posman and then start creating the create user.

So first, what we need to do here is so we can go here and then say and request and I'll say that request

names create user and then seem to springboard building blocks.

Right.

So a springboard building blocks.

So this is a create user and it's you are at least localhost.

Users, right?

So this is the thing and the method we are going to use is post method for creating end user.

So let's save build here.

So method is pushed in that you are a little more close to 80, 80 slash users, whatever we have defined

in our post mapping.

So now the next thing is to also have the body right.

So here is the body section, OK, in the body section, we need to select the right, OK?

And we also need to select the text bypass Jason application slash Jason.

So now we need to provide our complete.

So the best thing is to copy from our gut, tell you this method and then pasted here are we need to

write the DNA data saying your name is so-and-so, and then all those things, one, so that we have

a template available so we can go to the users and then copy this and then paste it to our create user.

So that is the best option for us.

OK, Furneaux, so just to save some time, OK.

And if you see here, so this is the data, decent data which were copied here.

So one important thing here is I.T. is going to get auto generated.

So let's remove that and username.

If you see it is a unique constraint.

So if you send back in Canada, it is going to throw that error.

It's the same with the SSN also.

So I can say.

User one right.

And then also I say SSN zero zero one, something like that, OK?

Zero zero one, because the SSN is relatively constrained, if you the same thing, it is going to throw

that error.

So this is the decent data.

You are sending it to our database now.

So let's save this once and then send it now.

OK.

Click on send.

So now our I.T. one got created with the user name, this one, and then, as I understand it, we don't

have any constraints on them.

So those were accepted.

So go to get our users and click on Sayne so you can see here I one we have listed earlier, only three

records.

Now we have four records in the same way.

Let's go back to our database.

So let me close this Posman and run selected connect and then I'll see select start from user right.

And then click on Land Selected, OK.

So you see we have the one we have here.

OK, so now if we do some change and then reboot the database means like the Davian then this record

will go away.

So you can even see that way because only whatever we are doing, there are documents like whatever

the data were in setting during the run, liberals will be there whenever the changes happen.

And then when really when the candidates, whatever the new record, whatever you have put, that will

go away.

So let me show that for you, OK?

So I'll say controller controller, let's see here, just the controller and then space.

And then I just I could just see some change.

OK, and then I'll click on C.

So now let's go back to our browser and then.

Cannot and then say select start from right so and then click on one selected see, you don't have that

record, whatever you have created, because it's a memory database.

Only when the Debian looks, all the records, whatever you have created as part of your testing from

Posman or anything, all those will go.

Only the records, whatever you have put it in, data will be available.

That's one important thing.

So another thing is you can see here.

So if you see if you go to the application that properties.

Right.

So you said that spring, that GPA that you're going through, which means in the console, you should

know what is happening whenever you create a user.

Right.

So let's go back and then create the same user.

So if you see here, only three users know, right?

So if you see forgetful users, what happened?

OK, so select the user, all the details.

So and so.

So and so.

OK from user table.

Right.

So all the what we call at variables are whatever all the elements from user table.

So it has selected and then it has displayed.

So what is doing is like the API is constructing disrespectable, no query against the database and

then fighting it automatically.

So that's what is happening currently.

So in the same way.

So if you create a user, what should happen.

Right.

So again, I'm going to send this and then create created because now the databases doesn't have this

record.

OK, so now this user should be for this.

You can see here inserting user and then it has created all the small details.

OK, see here.

OK.

So inserting the user and this is the order and these are the values it has sent inside.

OK, so.

Now we have got the user got created and then we have seen it in our hibernate, how it is created.

So let's go back to Posman and what we can do here is like we will try to create the user with the same

username, that user one, and then it should run error.

OK, see, I could not agree with the statement.

The only constraint that should be displayed here and the same place.

OK, I could not agree with the statement because of this unique constraint.

You means any constraint.

OK.

So here in the same way will go back to our idea and also the same should be logged here also.

OK, so we can see it here.

Both user and then SSN has the duplicate values which is not accepted here.

Right.

So that's the thing.

So we have seen now in the sadness that we have created to create user in controller there.

We have created the create user and we have introduced that direct request for the annotation at the

request mapping annotation.

And then we have tested a sample user using create user using Posman and then tested it.

We went back to the database and then understood that in-memory database holds the data only for that

particular time.

So when the GM dealers, whatever the new data you have inserted, will go away and also how to create

a create request in Posman with Broady and then content type all those things we have learned in this

lecture.

In addition, we have also seen the unique constraint that that's what we are going to get if we try

to create the same user.

So in as we are building this project in incremental manner to handle these exceptions and then your

customers messages, all those things we can see in the later part of the lectures.

But for now we have implemented the base, creating a certain method.

So in the next lecture we will implement douget user by idee method in both service and controller layers

and then based it.



Until then, bye bye.

Thank you.


### Step 26. Step-10: Implement getUserById RESTful Service - @GetMapping.md
Welcome back.

In this lecture, we are going to implement that get usability method in service and then control early

years.

So in the service layer, we are going to create a great user base method user by any method.

And we are also going to discuss about the return type optional object.

OK, so it is nothing but a container object.

And in addition, we are going to work on controller near where we are going to create a great user

by any method and apply the optional return for that matter too.

And we are going to introduce part variable annotation so that how we are going to handle the end user

research center in that you are your first request.

How we are going to handle we are going to see in the part variable annotation and we are going to also

annotate the current user by any method which we are defining and controller with the direct get mapping

and that you are we are going to define with the part variable Iot.

So that's about the controller layer, which we are going to implement.

So once that is completed, we are going to go to Posman and then create a request for this data user

by Irey Service and then test it so that you are going to use this like this OK, user slash idea of

that respect to you that we are going to pass.

So that's about it.

And the method we are going to use is get method.

So let's go back to our idea and then start implementing the user service.

OK, so we are in the user service now.

OK, so this is the one.

So.

Let's go ahead and implement that no.

So I'll say.

Public, the return type, you are going to return the user by finding it using that I.D., the return

type is user.

So how the return type changes to optional will see it not.

OK, so get user by idea.

And the input we are going to pick here is idee.

Right?

So that is something long, Heidi.

Now, what we need to do here is user.

User is equal to user.

Repository, not fine.

OK, so if you see dippie provides a default method, OK, from the repository also we can see here

find by right here.

OK, so which brought you to spread a better cloud repository here.

OK, so fine by Aidy and then whatever you want.

OK.

If you see here it's lupine type is optional.

So let me select this and then let's talk about the optional container object.

So optional is nothing but a container object which may or may not contain it nominal value.

So user might present or might not present.

So we need to handle that.

So how we are going to handle is provided here, which means like if you see here, we can check if

the user is present using its present method.

Right.

If present, what should be happen and then if not present, what should happen?

All those things will be available here in the fine by any method.

Right.

In addition, if you see here, we can also throw exceptions using ardell occupancy, Nevada exception

handling case.

What is Idelson then how we are going to throw that.

OK, so but for now or optional is a container object which may or may not contain the null value and

it has additional features for handling the exceptions effectively here.

OK, so let's go here and then change that type of user to optional users.

Right.

So in the same way, if I see a written user.

So you will also see that in the method written type two optional user, so now is returning the optional.

So this completes our service letter writing the user by the method.

So now I will go to the controller area and controller area.

We are going to define our gate user by any method here.

So in controller, we are going to introduce part variable now and then.

It's the new thing which you are going to introduce.

Let's see how it is going to be OK.

So.

Get used by Heidi.

Right.

So let me bring it up so that it will be easy for us.

OK, so I will say.

Public, as we know that we are going to return the user as optional user flight, so and get user by

idee.

OK.

And this is going to be our thing.

OK, so now we need to add the input, which means like whenever a request sensor uses with the user

data in that you are right, how we are going to handle is using a direct part variable like.

And let me say, the value is Idy, right, and it's five pages long idee, right, control command

shift all four are this one.

OK, so Java Yuta optional and the command shift or.

And if you see.

OK, so we'll add that written statement, no and written statement and no, we will call our users

real estate users.

Are we start that user by 80?

Right.

So this looks good.

So this completes the basic method.

Get user by 80 meter creation.

So now we'll also add it.

Did it get mapping here?

OK, get mapping and we'll see the context.

Does user slash, Heidi, whatever we have given in the path variable we are giving here.

OK, so we can read in both.

This one is like just first defined.

I get mapping and how the value here and then use the same value here or whatever to be flexible for

us.

I would like to write the method first and then I would get mapping.

So which tells me that this method, I am going to use it as it lists service.

OK, so that eventually I do.

So that's the reason I have written in that manner.

OK, so now this completes the creation of both service and then controller layers.

Now we'll move on to testing it in the let's say this and then we'll go ahead and enter this in our

postman.

OK, so we are in the postman now.

So in the spring, the building blocks project will say at request.

Right.

And we'll get user by Idy sale to Springwood.

OK, so now get user by 80 neutze

localhost and we see one, not one.

Right.

And then let me see it.

OK, so now we have save it and then we'll send the request.

OK, so now we have got the response for that user by 80 we can see the same in Nevada.

Cancer log query got fired here.

OK.

So at the end from user there are some details of kessell.

Oh what should I do with it.

Right, OK.

From user user user ideas equal to questionmark.

So it followed the request thoroughly and then we got the response.

OK, so method is good and user slash one zero one in the same way and say one zero two.

OK, I'll get one zero to let the user know.

So send it clear to the user one.

OK, so let's retrieve the user one or save and then retrieve.

OK, we got the user one.

OK, so we'll save one zero three.

OK, save and then request.

So we got the one zero three user.

So this confirms that I will get user by idea is working as expected.

And let's reiterate what we have done in this entire lecture.

So we have implemented or created a great user buiding service layer and we have discussed about the

optional object and we went to the controller layer and then implemented the get usability method in

control layer.

We have introduced the new annotation named apart variable.

So and we also about annotated the user by the method with get mapping.

And then we have provided that you are as user slash individually nothing but the part variable.

OK, and then we went to a postman and then provided different requests for one zero one one zero two

one one.

Like different users, we have created and then pasted this user by 80 plus fanservice there.

So this completes the user ID service implementation.

So I will see you in the next lecture.

In the next lecture, we are going to focus on our bit user by Demetrious input mapping.



Until then, bye bye.

Thank you.


### Step 27. Step-11: Implement updateUserById RESTful service - @PutMapping.md
Welcome back.

In this lecture, we are going to implement a big usability method in both service and then control

our lives.

OK.

In service layer, we are going to create a better usability method and we are going to accept input,

says both user and user object.

And then I saw in control earlier, we are going to create a user by method and then other inputs are

you are taking a different path available and also requests for user details.

And we are going to enter the controller layer with a straightforward mapping and now, once this is

completed, will run two policemen and then will create a request for a producer by idea with mapping.

And let me change the store.

OK, so the put and then we will go to body and then select RA and then content Jason and put and you

are a user slash idy so that we can do this.

We are, we can have a create user request to save us again.

I bet you that idea and then make some changes there.

But whatever the way we can do it.

OK, so let's go back to our idea and then start implementing the service layer for this.

OK, so let's go back to this idea.

OK, so now we are in the service layer, right?

So this is the service layer.

So let me make it bigger and.

So.

OK, so let's let the court here now, OK, so

you are saying that user I.D. is our method, right?

So I can see.

I bet you are by Heidi.

So what we need to do here is what we are going to return.

We are going to return.

We are not going to return any other status quo to our special messages.

We are going to say that we're going to return the updated user, Fano, because of their user base,

Heidi.

And then.

The inputs we're going to take here, are that the important thing, OK?

So the inputs that one needs, we are taking the.

Heidi, from our part variable, so it is nothing but long, and then we are also going to take the

user object from the request.

So we'll see user user.

These two are the things we are going to accept as inputs for this, OK?

And then what we are going to do is we are going to save this user to save this user.

What we need to see first, we need to use a dart, said Tidey and then Idy and then what we need to

say.

Written user

repository, dot sale and then user site.

So that's the thing.

OK, so now if you see the blade used by Eddie, so ideally, if in a real case what we do is first

we are going to check if that user exists, are not OK.

So we are going to just say implementing plastic is assuming user exists in the exception handling and

status codes.

Also, we can add additional steps here.

OK, but for now, what we are going to do is just very plain matter, saying that the user and the

idea and then said the idea in the persistent context, so user that satiety is nothing.

But we are sitting in the persistent context and the same user we are going to update with whatever

the user body we get it.

OK, so that's what we are doing currently.

OK, so let me say this and then go to the user controller.

Right.

And the user controller.

We are seeing that user by Heidi.

Right.

So now we are going to work on the update user by the method in our controller.

So I'll see public.

User update user by Heidi.

Right.

So two things are our inputs.

One is idea from the body and the body.

So what we need to take here is so that but variable, which we learned earlier, so.

And then we'll say it right, and it's.

Pipis Langone, right in the same way, another one is the quest body, right?

Request Broady and each type is user user.

OK, so this is our input, things which we are going to consider.

One is long lady, which is nothing but that variable idea and then request what a user user.

And then we are going to return the.

Think, OK, use a service, not a bad user, but I'd like with time and then user will update and then

return the same thing back to the client.

OK, so now for update, we need to use the Internet for mapping.

OK.

And another important thing here is so we are updating by Idy, right.

So we need to add the part variable here, but I'd like so and then also command shift or two important

book mapping.

So now if you see this completes our border service and then controller layer implementation for the

update user by idea using mapping.

OK, so now we'll go to either the client Posman and then test to test this one.

OK, so I'll go here and then say.

And request, OK?

And then I'll say update user and sell to Springwood building blocks, OK, and I'll say update you,

sir.

So let's start with.

Method method is put right and local horse blood, local horse users.

I also need to send the users one zero on what is the user.

Right now, let's go back to the body.

Right.

And then if you see here, we need to select RA and we also need to select the DNS application, slash

Jason.

So not to provide either your body or Utahraptor details.

OK, so we can get it from our user, whatever it is, OK.

Or we can get from our get real users.

So I get this from our.

So I create this idea and then I'll decide, OK, so what I'll do is so now I have created the EIGHTY-ONE

one, so let me.

Copy this and then go back to our producer and then.

Pasted, right.

So now we need to update this user, which is nothing but one user.

Let me save it here to here.

So users, first of all, that we are going to change.

So let me first get the user and see and make it user by 80.

OK, so this is my user details.

So I'm going to change the first name and last name for update user.

OK, so I'll save from Kanyon.

I'm changing it to first name updated in the same day.

I can make it bigger.

OK.

In the same last name, also say last name updated.

So let's go back to her, get used by the current ladies clan.

And then really now I am tending to first name updated.

Last name updated.

OK, and then I'll save and then send it.

OK, so now if you see here you the response.

Right, this got updated and I got the response the same.

Let's test the same using that user by.

OK, see my first name and last name got updated whenever I filed the update.

User request.

OK, so let's see if we are able to update the newly constrained details also.

So I'll say this as user two in the flight and then I'll see said that it gets updated.

There is no restriction.

OK, Soucy user Tergat updated so you can get user by ADC.

We changed the username to user.

Want to use a tool that also got updated.

So that's about the update user using Pook mapping.

OK, so now go back to our step here and reiterate what we have done.

OK, so we have implemented update usability, metering, service layer with inputs as both user object

and also the IDE sending them.

You are to have direct service.

So we have implemented the controller layer with the same method there and call the user service update

user by any method there.

And we have user the variable and then request body annotations.

Part of model for it from you are a request by referral, whatever the body you are sending in that

from the rest client.

And then we have annotated the controller with respect to method with mapping, OK, and then we went

back to our position and then created a request with body content type method and then you worry and

then tested it.

So everything worked as expected.

So now we will move on to implementing the delayed user by 18 hour next lecture.

.

Thank you.


### Step 28. Step-12: Implement deleteUserById RESTful Service - @DeleteMapping.md
Welcome back.

In this lecture, we are going to implement the user by the method in both service and then control

yourself over Springwood, the building blocks project.

OK, so first thing is to implement the service layer, which is create the lead user by the method

that we are going to verify if that user exists and then if it exists, then delete it.

OK, so we are not writing the expert here, but we'll discuss when we are implementing.

OK, so and the next is the controller layer and we are going to create a delete user by the method.

And then as the name usability user Obadi, we are going to take the input as part variable rate.

So here also the input is going to be the idea, the same way using part, whatever.

We are going to take the input from our service.

Urata.

OK, and then we are also going to annotate the.

Method with a direct delic mapping, and once both sadness and controller control letters are completed,

we are going to go to the postman and then implement their request further delete the user.

OK, so.

Let's go back to our idea and then implement the service layer now, so we are in the 80s, no social

service layer.

So what we are doing here is.

The lead user by I, right, and then we are not going to return anything, okay?

So it's like, OK, delete user by Iot and we are taking that input as long I.

And then what we are going to do is we are going to.

First check, OK, that.

User repository, not fine by.

OK.

That is present.

OK, so if that user exists, then I am going to delete it, OK, not delete by Heidi.

So that's it.

OK, so then if we find the user OK person, then delete it.

OK, so we are not we if a user is not found, we can send the user not a phone message and also his

status not for status to so those we will implement in our exception handling is OK so far.

No, let's close the method here and then move on to the controller.

OK, so.

It go to use a controller and what we are implementing now.

He's

the lead user by.

And here what we are going to do is.

Public wide delete user by Heidi and the empathies with part variable, right, and I'm going to say

I and Long Heidi.

Right.

And then I'll say user service start delete user by Heidi.

And we'll also add the delete mapping now a direct delete mapping.

And we are going to take the input first command shift or to import the delete mapping and what I'll

say slash user's.

Slash Heidi, right?

So let me say this, OK, so we have implemented the delete user by Idy method in both our service and

then control.

Yes, OK.

So let's go back to our Posman and let's create a new request here.

OK, so I request and delete user by Irey.

Right.

And then so Springbroot building blocks.

So let's click on Delete User by idee.

Open it and.

We will delete that user, whatever we create here, it is nothing but user one.

OK, so whatever we want.

OK, so I'll say user one and just buy this.

Right.

So and the method is delete and then sue.

So let's just go ahead and then create a user.

OK, so now no are one God created that user by 80.

So now I have that user here and then I'm going to delete it, OK?

Or we can even see that user in our get our users the first idea.

You can see it here.

Right.

So that is the one.

So I'm saying the user by eighty one.

OK.

And then said OK, so user got deleted.

I got that one response.

So now I'll go back to get all users and then see that.

And I don't find out one user here, only one zero one and then one zero two one zero three.

We one user is deleted.

So that's about it.

OK, so our user by idee, OK, service is working as expected.

So in all the previous look, just what we have done is we have done create user, get all users, get

usability, upgrade user by 80 and then delete user by 80.

So in the next lecture we are going to work on.

Get user by username.

So we are going to see the power of JP there.

OK, so we'll see that.

OK, but not likes to reiterate, what we have done is we have created a user by 18, our service layer

and then called the system from our controller layer.

And then we have also to then process both from the part variable as Iot.

OK, so we implemented both service layer method and then controller layer method and then we went back

to our postman and then we have to start out the usability method with methods delete.

So that's about the user by a limited implementation.

And then in the next lecture we'll work on that user by user name.



Until then, bye bye.


### Step 29. Step-13: Implement getUserByUsername RESTful Service - @GetMapping.md
Welcome back.

In this lecture, we're going to implement that user by user name, Metaldyne Repository User Repository,

User Service, and then user controller layer's.

So in repository, we are going to be fine, fine by user name in a matter of user repository interface.

And we are going to define the same service layer and then call that from the controller layer.

So any FESSEY input we are going to take for these things is user name, which is it input as username,

which is nothing but a stream type.

OK, and we are going to annotate it with a great, great mapping.

And also we're going to use that you are to ask users slash by user name and the variable user name.

So we'll see why we are moving by user name and we are implementing the controller layer.

So from personal perspective, we're going to create and verify that that user by user name plus full

service enforcement plus client whose method is good and the water is going to be users by user name.

Slash user name will use the name.

What is present in our database example, cariddi device or whatever the three test records we have.

Right.

Those things.

OK, so we need to provide the user name.

So let's go ahead and implement this in our highly, you know, so.

We are in the user repository.

So let me this is the user repository.

Let me make it bigger.

So now my method is going to return.

Users might get user by user name means it's going to return the user.

So the return type is user.

Right.

And find by IED.

We have seen if you see in our repository methods, if you see here, just let me go here and then say

user repository dot find you can see here find all find all with paintable sart example find all by

identifying, by identifying one and then find a buyer.

So like this everything is fine.

Right.

So what we are going to do now is the same thing.

OK, so we will save this year and we'll go to use a repository and we'll see a find by user name.

So we need to view capital.

So our user name is whatever we have defined in our entity like user name.

We are going to find this user name.

Just we need to give the capital you here.

OK, so find the user name and the input for it is king and then user name, that's all.

So instead of writing complex queries in the older style, well in our earlier implementations when

we are using databases are my bet is all these things we we are supposed to write complex queries like

select user from so-and-so table where the user name is equal to so and so like that.

We need to write a big amount of queries.

OK, but for now in this Jipé implementation, it's like only one liner and BJP will take it off finding

the user using username and then display to us.

OK, so just by using find by username.

So now we have implemented it custom method name defined by username and this method we are going to

call another user service.

OK, so let's go to our user service and then implement the same.

OK.

So here is the thing.

Right.

So let me push this up.

OK.

So I'll see.

Get user by user name method.

This is what we are implementing.

So what we are doing here is we are going to return user.

My name is getting served by.

User name and input, we're going to take your string username and simply we can see written.

User repository dot find the user name, as we have defined find by user name in our repository interface.

Now what is available for us?

Why are use that oppositely that?

So now we are returning the user repository dot fine by username.

So.

And another thing is one thing to note here is so how we have came to a conclusion that it is going

to return only one user, not to multiple users, may not.

It is a list, right.

Because we have defined user as a unique constraint, which means only one recarpet will fetch many

such users by user name.

That's the reason you never repository.

We didn't mention it has a list.

It's only a single object user.

OK, so that's what we have mentioned here.

OK, so that's the thing.

Important thing that we need to look into whenever we are writing a method in our interface use repository

which extends the repository interface, we need to ensure that what will be timetable's, we are going

to have issues.

Right.

So it's only a single user that we are using user, not the least users.

Example, if I said find the use, find by last name, OK, and I might find multiple last names, it

doesn't have any unique constraint and I might have duplication of data also from last name perspective.

So at that time we need to set list user.

So these things need to be calculated and then written accordingly from us.

OK, so I'll save the repository and then I'll come back to user service and I'll say this also and

I'll go to the user controller now.

So and then I'll implement that user by user name method here.

So get user by user name.

So I'm going to return.

User.

And my name is user by user name and my input is going to be important here, right?

It's part variable and input name is user name and itself type.

Right.

And then I'm going to say I'm going to call my Twitter user service DOT.

Get user by user name.

Good.

So that looks good.

So one final thing is we need to add that get mapping.

By this time, you would have been experts in writing the services controllers and also defining custom

methods in our repositories.

So let's do this now.

So sourceless users slash by user name and I will say part variables username.

So let me save this.

So.

This completes get user by user name method creation in controller, also, let's go back to our Posman

client and then create a new ad request rate ad request and then also get user by user name and then

sell to Springboard.

So let me rephrase that.

Yeah, here it is.

OK, and let me open this and now localhost users.

Right.

So now we are going to get the user.

So let me get the list of users first and then their names.

OK, so my username is Cariddi here, ok.

So let's search for curity see and then send.

So I have a panel here.

Let me see what's going on.

Good.

So now you know that what it is saying is fail to convert a value of Java Langstrom to Java Lang Lang.

So whatever.

After users, whatever you provide it identifies you or your request as which you are sending for the.

Get used by that study they do expecting a lamb instead of a string, right?

So that's the catch here.

So that's the reason we have given here by username so that it's a different context.

Right.

So now let's save it and then send it.

It should respond properly.

No, see, so we have got the carry the user then we have sent it via username in the same way.

Will also test for divisor one more user which is present in the database.

OK, so g ricer.

So let me send it.

So we got the user.

Let me convert one user now so and so.

And you were named Tom Wright so I'll say Tom and then Sue send right from God created.

So let me.

Access that user, OK, said I got the user right from now, let me make it to murder case, it should

feel OK because we're going to take the input and make it stronger and then send it back, OK?

That is the thing.

We didn't try to make it the case sensitive, right.

Court.

So let me see this, OK?

I see it fail, but it failed.

But they didn't see any error because they're going to implement the exception handling.

But that's the thing about.

Let me again try forget it and then we should be good.

Yes.

So this computer to get user by user name, customer definition in our user repository and then call

it a user service means like call it in the user repository that find the user name GoPro user controller

and then implement the same in our user controller with the different context, not under the users.

When we implement the same thing under users, then it gets confused with our existing service, which

is quite user by I.T. So that's the important catch we need to remember here, so much so that we have

completed the gate user by user name.



Until then, bye bye.

Thank you.


### Step 30. Step-14: GIT Commit, Push, Merge to Master and Push.md

Welcome back.

In this letter, we're going to work on commitments to master and push it to the top.

So in previous letters, we have created multiple services for you just by idea, get users by user

name.

We have broadband, create user service, all these things.

Right.

So now it's time for committing all those changes to the user management service based branch and then

push those things to the GitHub repo in the same way once we put this plant in and get to the top repo,

but also going to match those changes to the master plan and also then use that also to the GitHub repository.

So let's go back to our idea and then make those things now.

So this time, we're not going to use the command.

We will try to use the word I need to do these changes.

So what about if you go to that stadium here, right in the stadium view of the city so we can see these

are the files which grouching that's part of this directly TGP user management site will be spelled

out.

So which means we have made to invest or use about Java user controller and then use the repository

user service, all these things.

OK, so what we'll do now here is we'll go to that staging and then select all these things and then

drag them to the stage changes, OK, and I'll see the messages disappear.

This list services.

Development.

Completed, right, and then I'm going to do that when you come out of going to come to a local branch,

that is nothing but three years in management be spent if a committed.

The changes will also be Pashupati.

But so play the guitar also, so I'll take a little push, so and the remote origin is about slash tax,

simplify, slash python building blocks that deep inside the branch manager at the management service.

OK, so I click on next.

OK, so I'm going to finish it up from following you expected from here to here.

I'm doing the push, which is nothing but gratitude from local to remote.

OK, so I click on finish ok.

So no, but got completed and then it should be available in negative ripple.

OK, so we'll go to our gate stage and get the perspective here, OK?

And then I will what I do is like I'll try to refresh this, OK, so I can go to file and then to refresh.

OK, so now if you see the business services dial up and that is the code and then we see for two zero

three six C two zero three six is the color code here.

Right.

So in the same way that also we should see with the same chemical, that looks good.

So now if you see the is still not in sync in local and remote.

So what we do is first of all, check out the master.

So critical to master.

First, we need to go back and moonshadow if it is running.

So I shut down my division and come back to the perspective here.

And then I will check out Mostert so that now I'll be the master branch.

So I'm in the master branch.

All right.

So what I'll do is I'll see much my master branch of it, the management service base.

So now I'm adding the masterbrand with the.

So all the changes need to in this present will be merged to the masterbrand aspect of this change.

OK, so now if you see Masterbrand talked about the same connetquot for Beat 360 and also by the same

committee.

Right.

So what you.

So now in local, both my master and 012 appears in sync in the same manner I to push it back to a remote

repair, which is nothing but our GitHub repository.

So I'll push and then I will produce a remote origin is spoonbill building blocks Bradgate understocked

simplify a code and the branches master Sensipar you implement it is going to say master to master.

It is going to think I click on Bush.

Right, so, no, if I go ahead and then see what you can see, even smell so hard for me to so know

that he has not completed and then we have to everything to our GitHub repo Max.

We had a number for the same one.

I get report.

So vulnerable Stack Simplifier contains the Building Blocks project and we can see the utilities committees

for at least six minutes before and which is nothing but a business services development computer.

So business services development is completed and then it's equal and could be pushed in the same way

for better to master and then see the blueprint also will find the same for me to directly succeed.

So this confirms that whatever we have done so far, it is already now available in our GitHub repo

also.

OK, so in the next letter will focus on exception handling and status codes and all those things in

the complete next module, not even lecture, but in the complete module will focus on implementing

the exceptional handling and also.

Oh, it has to be status quo for all these other services which we have built so far.

.

Thank you.

