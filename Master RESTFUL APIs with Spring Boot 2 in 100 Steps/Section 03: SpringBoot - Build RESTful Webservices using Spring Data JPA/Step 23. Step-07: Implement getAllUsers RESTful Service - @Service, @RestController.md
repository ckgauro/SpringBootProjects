### Step 23. Step-07: Implement getAllUsers RESTful Service - @Service, @RestController .md
Welcome back.  In this step, we are going to implement guitar users method, so to do so we need to create a service  layer and also a control layer.  So for service layer, we are going to create a user service class in services package and then we are  going to annotate it with a direct service and then we are going to auto where the user repository in  the services layer.  So this concludes our services section after creating the guitar users method inside that.  So these are the things we are going to perform another service layer in the CMB, in the controller  layer, we are going to create a user controller class and then annotate that respective class with  a direct rest controller, which is nothing.  But it is going to the vegetable layer, which means like from browsers are from less claims.  We will be able to communicate with our other services using this layer.  And then we are also going to operate the user service, which we have created here in the controller  user controller.  And then we are going to create a method that will use this method and then annotate it with.  It direct get mapping, so we are going to create a great kidnapping, forget I'll use this method which  we are going to create in comptrollers user control class.  So this is what we are going to do in this lecture.  So primarily we can directly create the controller and then we can leave the service layer.  But to follow the standard design patterns from coding perspective and all the we need to have the service  layer in the service layer we can have in a number of business logics can be implemented.  So but we cannot implement business logic.  Seems like it's not a standard practice to implement business logic since the controller layer because  we have that has to be affronting in that area so we can define any number of methods and then have  multiple objects in the service layer.  So to follow standard design patterns.  So we are following those things to ensure that we are in compliance, like we can use this product  as a template.  One more thing is we can even create the interface in service layer and then create the implementation  class and then create all these things in the implementation class, too.  But it becomes only longer and longer for us.  So that's the reason we are just debating or taking a minimum level shortcut that we are just creating  a service class.  We are not creating any interface class and then implement it in class.  We are just creating only one class user service class in the service layer.  So let's go ahead and then do that now.  So in service layer, our first steps are to create a user service class annotated with a direct service  and then AutoReader user repository and then go ahead and then implement the GETÃšLIO this method.  So let's go back to our idea and click on our main package, rest services, and then I'll sit class.  And now we need to create a package named.  Services, right, and in services we are creating, you use that service, OK, and then I click on  Finish.  So now we have the user service.  So this is it.  Service.  OK, so which means I'm going to annotated with a direct service and then I'm going to see a command  shift or which means I'm going to import that respectable package.  So next stop all the way to the user repository.  Right.  So we'll say private user repository, user repository.  And we are going to come out of code to import our user repository and then we'll see a direct APPLEWHITE.  So which means we are going to out of a shift or to import part of a package.  So now we have automate the user repository.  So now let's go ahead and create the get all users method in here, OK.  So to create a gate all users method, we can say that when we are retrieving all users we can consider  that as a list.  Right.  So public and our prototype is going to be released and what type of things we are going to return,  which is nothing but our users.  Right.  So we need to add our user entity here and we say get our users use my method name so it will not have  any input parameters.  So I leave it as it is and then say enter.  So let me put first to the user entity here and also Java.  You can list.  OK, so we have input both the gelatin list and also the user entity.  Right.  So now let's go here and then create the minutes like list all the users to do so.  What we need to do is user repository DOT.  JPA provides direct  methods for all users, which is nothing but find all.  Is the metadata repository, we can see it here, see the repository and then find out, OK, returns,  all instances of the type, so it returns all entities.  Right.  So find all so we can see we can return the SIM because our return type is also listing the end user.  So now this completes the let's save this, OK?  And then we don't have any issues here, OK, from the log perspective.  So we have implemented the data with this method, another service layer, so that it can type a list  and then use it and then get all users and then the repository that find all that and the same thing.  So this will return to our list of users present in my HESTA database.  So this completes the service layer creation, by the way, just to let you know that we are not implementing  currently any of the validations or any of the exception handling or has to be status codes in return.  All those things, once we complete the best project with all the methods, which is like get all users  and then create user update user, get user by user name, get user by idea and also delete user.  Once we implement all these methods and then get a hold or comment on those methods, then we will extend  our project to implement exception.  Handling for every method and also implement has to be status quo.  Just like 200 or to zero one created are four zero for when I try to find a user, get user by username  and get user by idea.  So if I try to find a user, I can throw the folder for the user is not present.  So like that are custom messages.  OK, so now we want to create another controller as we completed our step up for creating the service  so that the users method will move on to creating a better controller.  Now, OK, so let's go to our main package and then send a new class in the package.  Names, not controllers, and we are going to create user controller.  OK, and then click on Finish.  So now if you're seeing the controllers, so we need to have the controller annotator tell Spring that  what type of controller is this?  So we'll see that list controller.  Right.  And then come on to total import our controller package right now and then know what we need to do is  we need to automate the service.  Right.  So automated user service.  So I'll say.  Bloviate, use a service, use a service, OK, and then I'm going to automated that and then I'll take  a much of total input, the respectable.  Package.  OK, so now we are told that.  Use that, so let's implement the guitar users method here, OK, so our guitar users method is going  to be public laced and user, so it is going to list a list of users.  Right.  So and then I'll say guitar users so it doesn't have any input parameters.  So I commend you for to import that into this user and also Jabuti list.  OK, so we have input both and then we are going to return user service, start get all users.  Right.  And then it.  So here we are clear.  So we have defined a method which will return all the users.  OK, so we have called the user service DOT, get all users matter, whatever we have created, just  no disrespect to matter.  And this respective method will call the user repository DOT.  Find out.  So we will bring the data from our database.  OK, so now what we need to do is we need to annotated with a get mapping, which means we need to give  the whole city bilayer for that.  OK, so I said get mapping and we need to provide that.  You are a control command yiftah and then I'll slash users.  Right.  So.  And then see.  So this completes our control part, which is nothing but whatever we need to define in our less control  effort to use this method, we have completed it.  So in the next lecture, what we are going to do is we are going to test it using that Posman line.  So we are going to all create a request in a lot of Posman clients and then test these things.     