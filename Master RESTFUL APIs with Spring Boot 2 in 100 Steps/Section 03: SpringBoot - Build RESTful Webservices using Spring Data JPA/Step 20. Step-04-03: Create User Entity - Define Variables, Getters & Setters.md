### Step 20. Step-04-03: Create User Entity - Define Variables, Getters & Setters.md
Welcome back.  In the previous lectures we have discussed about the great entertainment table annotations, so now  we are going to create our full set variables in our respective entity.  So let's go ahead and do that now.  So our.  First one is private law, Heidi.  So this one, we're going to consider it as our primary in our people.  So we'll also see private string username and you'll also see.  So the reason we are taking multiple instead of doing it with one or two Marable's, we're doing that  with five to six or seven variables is to understand better in from better perspective than we are writing  the data that Ezekial Farishta database and then how it is going to be all those things.  OK, so let me do one thing now.  So it is just me right in the same way.  Will also do will also define private string last name and.  Private.  Private string.  Email.  Revegetating.  Rule.  And then private string SSN, so we have declared the seven variables now, so we'll start with the  first one, OK, which is nothing but the private long idea.  So to.  Tell in depth that this is going to be our primary key, we need to annotated with a direct.  Right.  So when we annotated with a retiree, so dippie makes it as our primary key.  OK, so develop a system that works.  Persistence, Heidi, was important.  Not so.  You should have a primary key which uniquely identifies it.  So a great idea, annotation defines the primary key here so we can generate the identifiers in different  ways, which are specified by a direct generated value annotation.  So if we are here, the generated value so we can autogen the.  Value for this.  I do feel OK in an incremental manner or whatever.  So we'll have other strategies available here for at regenerator value, which is nothing.  But our two people sequence our identity.  So we're going to use the default.  We're not we're not changing anything here or we are not doing anything related to adding strategies  and all those things as we are going with the basic DP application.  I'm just annotating it with the data generated value.  So now moving on to the next one, which is nothing but the username.  Right.  So in our database, if you feel like if you leave it as Defarge like this in our database, the column  name is going to be directly username.  So instead of that, if my database needs a different name or if you have an organization, has database  standards, we're naming convention should be in this manner.  So as our Java code naming variables and then database we're naming conventions will be totally different  in reality.  OK, so if you want to follow those things as per our global standard, so we need to use the annotation  in the red column.  So Comanche's to OK, so import my red column up.  Bacquet So what I do know is a column and the elements it will have is like we can send name.  Right.  And I can see Yuzu underscore name is my column name in the same way if I see you and I can also define  the length of this field.  OK, so this is only applicable for string type.  OK, so and then my Lentulov, my string is going to be not more than 50.  So in the same way I can serve a database.  The main thing is whether it can be nullable and not right.  So I'll see Nullable is false.  And one more element for Aderet column important one is unique.  So defining disrespectful column as unique constraint are not so example of a defined username as unique  constraint.  If you try to or if you try to create a user with the same name again, then it's going to trial and  error.  So for username, we are planning to use it as a unique constraint in the database and also it creates  the index.  I'll show you in the database.  I would God created the unique index with this once we define it as unique.  OK, so now we have the column defined here a the red column name user name is equal to false and then  unique is equal to two.  Right.  So so in the relational database world, if you see a table can have only one primary constraint.  OK, but we can have multiple unique constraints.  So considering that statement.  So what we can do is so we can copy this and then so we can even define the red column for the SSN.  Right.  So let me make it bigger.  OK, and.  And I'll say.  Name is called SSME.  Length is equal to 50 and nullable is equal to false and unique is equal to true.  So we have defined a particular constraint in this table, which is one is SSN and the other is user  name.  And we have one primary key named Ida.  Right.  So let's also define the data column.  And the name is equal to first underscore name.  And Lent is equal to 50 and Nullable is false.  So let's define the same things for the other two there.  Three.  Variables, too.  OK, so I'll see.  So see.  Last underscored me and I'll say e-mail address and I'll say, OK.  All right, so these are the things that we have defined here is a typo, so name.  OK, so this completes the variable rate column annotation.  Definitions like means like discussing about the name Linda Nullable and then unique elements inside  the Aderet column, and then we have applied those things to these variables.  OK, so now what we are going to do is so we need to define it.  No argument.  Constructor, OK, and the constructor.  And also, one more is dippie will not be happy without this argument, constrictor.  So definitely we need to have it.  And one feels constructor and.  Getters and certain soccer fields, constructor is optional and in the same way, bootstrapping is also  optional.  So these things are optional, but no argument.  Constructor and then gittleson sectors are mandatory things.  OK, so let me add those things, OK?  So let's go to source and then.  Dendrite.  Constructor from Superclass, OK, so it's generated now.  So let me remove these things.  OK, so I will copy this.  And then see no argument constructor, right, and will also define the field's constructor and all  those things.  So let me define those things here.  So Sors generate constructor using fields and we have generated the constructor using feel now so we  can cut this and then paste it here in the same way.  Will also defended the getters and setters.  OK, for all the fields.  So we have generated the that doesn't set us now.  So let me take this and then.  Put it here, this is just a comment.  OK, and now two string is also this is an optional look when you want to do troubleshooting and then  enable logging at the cabin level.  So we need this, OK, optional required for I've been logging.  OK, so I can say like this.  OK, so this is an optional thing, ok.  So if required we can do it are if not required we can leave it.  OK.  So what I'll do is like I'll generate it.  OK, so that's fine.  OK.  So we might, it will be useful.  OK so.  And then generate two string.  Right.  And then generate it.  OK, so we have also a generator though to string.  And.  OK, so this completes the creation of the user entity, so let's go back to our.  This one, yeah, step, so if had read what we have done for recreation, so we have discussed it in  lectures about what is a great entity and its element, name, element.  And we also discussed about the table and its name element and also the schema element.  And then we moved on to creating other variables here with its user name, first name, all these things.  And then we also discussed about a great idea, which is nothing but up for debate.  And this field is going to be the primary key and also provided a great generating value for generating  the members of the incrementing the members.  And it has different strategies available.  And we really didn't discuss here.  It goes very in-depth when we start discussing those things.  But it has four strategies which we didn't focus yet, primarily by focusing our little steps when we  are doing deep in depth.  OK, so now in addition, we also discussed about the red column and the column annotation and we have  discussed about its element, namely the nullable and the unique, primarily to focus on the red column  is the unique constraint means like defining any attribute, are any variable as unique in that respect  to table we need to use the unique is equal to two.  And also we have defined the normal construct Bradfield's constructor and also the two string in our  respective entity.  So this completes the integration.  So we'll move on to the next step now.  So we have completed the integration.  Now we need to focus on creating the.  Repository.  OK, so I'll see you in the next lecture and in discussing about the deeper repository.   