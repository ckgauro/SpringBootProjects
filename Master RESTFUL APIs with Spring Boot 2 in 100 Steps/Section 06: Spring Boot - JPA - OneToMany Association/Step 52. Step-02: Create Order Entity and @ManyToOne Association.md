### Step 52. Step-02: Create Order Entity and @ManyToOne Association.md
Welcome back. In this lecture, we're going to create another entity and to one association are that entity. So let's see the series of steps involved in creating this other entity and translation from user. So let's go back to the code. So if you see here in steps, we're going to create the entity with many to one mapping. So in the entity layer, we're going to create another entity and then annotated with able annotation what the problems are this. And then we're also going to add user found in addition to the other or the radio, the description forms here. And then we're also going to map annotate the user from the minute one association and then we're going to add the first step as and also annotate the user feel with Gisenyi. And we're going to generate Wooderson letters and not non-human constructor. So these are the steps that we are going to perform on the intermediate for other entity. So let's go ahead and then implement them. So very much so in the NTD package and growing up in class named. Order. Right, and then I'll click on Finish, if you see this is in line to this package. So this is a order. So as this is the entity and being annotated with entity command, shift in product package, Jarra X persistance entity. So as we discussed in our introductory section, we're also going to say that people. Right. So people and it's me is going to be hard. So come on, you've got important jokes, persistance people. So now the next is the phone's in order. And so one is private, long and I'll see you already. Right. And one more I'll. Private string. Audio description, so and if you see on radio, I'm going to annotate it with Heidi, which is nothing, but I'm going to make it as primary key and I'm also saying that so let it happen. It will keep generating the upper income for the ladies. OK, so generating value and for both the things come and shift to important dynamics, persistence idea and it's equal and generated value package is OK for persistence. So now the next thing is finally the user. So if you see here, so I say first let me write it down. Private user. User. Right. So we're going to create the association of the relational mapping between user and the order. Right. So there is no other entity now. Right. And we're going to create a relation to the user. So let's consider like this so one user or multiple orders can associate with one user correctly. So this is the other entity. And we are saying that multiple orders can associate one respective user, which is nothing but many to one relationship. Right. So multiple orders in the other entity are those can be associated to one user. So let me add. To annotation an additional government yiftah, so no unabating use. Whenever we are fetching the data right. So, as we are saying, this is going to be a by election mission, which we have discussed in our introductory section of this JP one too many. So what we said is it's a bidirectional relationship, which you are going to implement. So when we're implementing bidirectional relationship, so when we are not careful about the types, then it's going to end up in the recursive loops. Right. So we are going to say to want to listen in for this user object, we are going to see a fixed type as lazy. So what we are saying that, OK, so when you see a first step as lazy, which means until and unless I say either BOBERT user, this user object is not going to be fetched in this other entity whenever the request comes. OK, so which is a good thing. OK. So. Which type not lazy, so that's the reason we made it easy for Stip lazy. So another thing is we are going to also add Jason Egnor. So if we don't see this anymore for this, so what happens is whenever we are creating the order. Right. So it also expects user data to be sent and that's not right. Right. So like this, multiple things will occur here. And the first thing here is we're trying to implement the first set of very high level of abstract layer of annotations, OK, which is manyatta one one p.m. Napperby, these things. OK, we're not going to the next level with your giant column, giant people. OK, so JP has given annotations in multiple orders. OK, so if you're dealing with a very high level, which means like the first level of first order of annotations, like one too many, many to one and then Napperby and not using the second order, which is nothing but than column design table, all these things, which means like we are writing a more cleaner code. But if the necessity and pressures are still going to join Kormann joint, we can definitely use them. But first, we should try to implement our things with the primary level annotations. And then if that is not possible, if the situation is too complex, then we need to try to jump into adding the giant column. So here you can even see gyne column and then say you already saw that. It can be possible, but why you need to use the second order annotations, let's use the first order annotations is the core logic here. So that's the reason we're using Minetta when he said what we will try to use the Napperby so that the association becomes TUTTO. So we'll see that when we're discussing about any association that we have implemented a minute one with typos. So now the additional things, what we need to implement here is. No argument constructed, and that hasn't set us suspended constructors from superpower's. And the other is sports and Janet Bettison, Setas Selectable and generate. So now if you see here, so we have completed creating the other entity. No. So let me see this. And this completes the identity creation. In the next step, we're going to work on creating the user entity, which is nothing but other side of the equation. So I'll see you in the next lecture then. 
