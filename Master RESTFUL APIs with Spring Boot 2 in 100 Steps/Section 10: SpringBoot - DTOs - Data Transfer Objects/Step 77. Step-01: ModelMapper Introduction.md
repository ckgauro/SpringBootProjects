### Step 77. Step-01: ModelMapper Introduction.md
Welcome back. In this section, we are going to understand and implement the divorce using model Mappa so that most for data transfer objects. OK, so exposing identity objects to resting points can make security issues provided if you don't take enough care about which entity forms should be made available for publicly exposed missteps. The library, which supports to convert into objects to be diverse and also be transformed into the objects. So intelligent, insightful, but there is no manual mapping needed, so when we're using it and automatically projection when it flattens the complex models, whatever we have. So it's also refactoring safe. So a simple flying paper for handling special use cases. If you have a different model for entry to detail conversion, a conversion perspective, the APIs, typesof and also refactoring. So if you see here, it's a conventional convention model. So model map approach predefined conventions and if you can also create his custom conventions if required. So it's also extensible model, motor support, integration with any type of data model. In short, model mapping does the heavy lifting for us. So from the forensics perspective, we can talk and model that are getting started for an additional understanding and documentation perspective. So the implementation steps, the Swiffer model, Mappa, so fustiness, as usual, we're going to create a new plant using Idy for our model matter implementation. So and then we're going to add more than dependancy from that XML that will go into a core implementation. That is. First, we need to define a model Napperby config and then annotated with a do put it in context. So then one more detail layer. So which means like we're going to create a new package database and under that we're going to create a new class with names user. And so just to identify, we can directly reduce the debt. But in our next leftest, we're also going to implement the similar type of model method implementation, which is nothing but abstract. So I really don't want to have different, different things, which means we really don't want to have a single thing used for implementations when it's for more than apparent benefit. Mastech, so that's the reason I'm getting closer to a meteorologist Zimmermann's model Knepper in the same bed in the next section where we are going to deal with an abstract for the same type of detail to entity and entity to detail conventions that I use it. Yes. So Emmis means map stability so far that what changes are required in order to be there and then here, whatever is required for this respective model, Napperby will remain with you. So if you see we're going to create a different package under which we're going to create user data, a file and from controller perspective. So what we're going to do is we're going to create a new user model, better controller and copperplate usability plus from our regular user controller and then implement the model metallurgic, whatever is the conversion logic we're going to implement. Finally, we're going to test it and then come out and push it. So let's see one more time the detailed steps from a federal court perspective. Right. So here are the steps serpens unspinnable to this model. Knepper So if you see here, the first thing we're going to create with branches in Nidhi and then we're going to implement, it works for the user entity using model Mappa. So we're going to update the bombastic symbol. Right. So this is update from the XML. With more than Mirpur dependancy, later, we're going to define moral Napperby conflict. So we're going to create a conflict package, conflict class and then define model Mathabane in that. At the same time, after that, we're going to create a bit of a class with who's was right in the name fields. Once those two are completed, will go and then move on to competing in the country. We could use a model map or controller and then annotated with the rest controller in the request mapping at the class level. We are going to give us the services. We are going to have as model maps, users, users, if you see here. So I have organized all over the place whatever we are creating as part of this project like this. OK, so your basis initially, whatever we implement to get all users created will create order based usability and all these things right after that. When we're doing the implementation, we are in need of creating a different context with different controllers. Right. So we have to do these things there. So this is the same way for internationalization. So in the same way for filtering. We have done these things for the assembly and then mapping Jackson. So in the same way, no further details. Also, we're going to have a separate from the here and then we're going to create a model map related to services, whatever we're going to build in that folder so that this of package Posman package you can input and then you're in your Posman client and then use it whenever we're implementing the course. So we are going to create a separate contextual model map of users and then implement that which is a bit of a bad idea, and then implement the model mapper little there and then best using replacement. And then we want to to the corporate idee. So that's all we are going to do, step by step process. So we are going to implement everything in six steps. OK, so excluding the additional steps which are the latter two, step one and then step six, which are the letter to commit quality to it. So you can say two, three, four, five, within four steps you are going to understand and then implement a complete model mapper. So I'll see you in the next lecture, basically going to the idea and then implementing it. So . Thank you. 
