### Step 80. Step-04: MapStruct Introduction.md
Welcome back. In this section, we are going to understand and implement detours using Napster. So Napster is a code generator that simplifies being mappings. So mapping classes are generated, a compilation and more runtime processing. That reflection is used here. So mapping classes use simple method in location, which makes them really easy to debug. So we generally notice a lot of boilerplate code converting pages to other products. So very common type of conversion we see regularly is in between persistent backed entities and data that go to the client site. So the problem Napster solves is it can generate between upper classes automatically. So if you go by implementing those been upper classes manually creating being Napoli's, the time consuming process, and here with Napster, everything will be very much automatic. So Napster, it also requires a processor plugin to be added to the problem. But in addition to collector dependancy, so the Napster process is used to generate the matter implementation during the build phase. So let's see the series of steps we are going to enroll in Napster implementation. So as the first thing we're going to create, they will get Branch using idee, as usual, for all of our steps. OK, so I'll take the pragmatic semmelroth, necessary dependencies. We'll see what are the dependencies in a lot of detail steps. So then we want to create a new user and data, a class record for mousetrap implementation. If I see here, user and data is nothing but user maps that do so to differentiate our user. And it is nothing like model. So we are seeing this as a misleading and we are going to create the abstract mappa interface and then we'll create web services by calling the method defined in my abstract mapper. So in the abstract Mappa interface, we are going to define the method and those methods. We are basically going to call from our controller area. Finally, we are going to come and then push the caller ID. So if you see our steps here, right. So step one is to convert it into the Springboot Matchstick branch and then they'll go to a letter from that example and then add the properties for our abstract version and then Aperture now and plug in version for Mastretta processor. OK, and then we will also use the one three zero final, the current version, which is going on with the map struct. And we are going to also add the maps that dependancy and we are also going to add more abstract processor plugin. So in our total plan that XML, we are going to make three changes, OK, and then go to the step three, we will create a of class and then we'll create our fields and then we'll also create an argument and then fill constructors and also generate the data centers. So then we'll move on to step four off map Strittmatter interface. So in the map and interface, this is a key thing now. Okay. So we are going to create the interface with methods for mapping between objects. Okay, so we are going to annotate our Mappa interface. We will create a map and package and inside that we are going to create a map interface and that neighboring. Our map interface, we are going to annotated with maps. So then they will configure the maps to use spring dependency injection, so then we'll move on to nothing. But we're going to add a component model with a spring as the string. OK, so then we want to create methods, which is nothing but user to use a dual. Right. So this is first method we are going to create and one another user to user details. So far, the improbabilities going to the user and the output object is going to be user remise. DTL So in addition in know local select no exact user entity. We see the name as e-mail and whenever we're creating the data, we'll give it to us email address so that we also understand about the mapping annotation available here. OK, so in the source we have the email and then the destination. We have the email address so we can map that on top of things like we can add the sanitation on top of those respective methods so that this email to your email address will be mapped accordingly. So there will be some situations where our data addicts need a different a few names instead of whatever is present in the entity. So in that case, that's how we're going to use the mapping. And when using the maps, truck mapping annotation, how we are going to use when we're using maps, we're going to see that. So this is for our user to use the data. We can say that to get usability, you can use this one or create user. You can use this one. Right. So why? Because it is its user object. OK, but here, if you see it is like you said, you said it was nothing but a list of users. So input this list of user and all the stuff that I'm listening to us. So which means it is for all users method in our control. So these two things we are going to implement in detail and understand much more effectively. Additionally, we are also going to see the mappings, which is another additional feature for mapping the source and destination letter fields with the different name. So when they have different names, so finally we are going to create a service and build even better service. We are going to offer better service. We are going to create a new user maps that controller so that all maps regulatory implementation is separate for us. Right. And we are going to propagate user by user methods from user controller and then implement them effectively in relation with other users, what we call integration with our map interface methods, which means like in mapping interface, these two methods are that we are going to call when we are implementing these two matters. Finally, we're going to test them and then commit and then push the code where Iot. So this is what we're going to implement for the entire. Mousetrap implementation, so let's go ahead and implement that now, so I'll see you later.
