### Step 82. Step-06: MapStruct - Create UserMapper and Implement getAllUsers Method.md
Welcome back. In this lecture, we are going to understand and then implement the following three steps. One is clear, the maps try to map out interface and then we'll move on to once the interfaces that will create the equal interest services and then calling them methods defined in this map interface. And then we will test them and then committed posterboard. So all these four, five, six, these three steps, we are going to combine into a single lecture now. So in the years code, we can see those steps in detail. Okay, so this is step four to create the magic map interface. So let's go ahead and implement this step now. So my mapping interface name is User Mapper and I'm going to create a map of package now. So let me go here. So the PWP created the database, right. So now we'll go to our. The services, your main package, and then see a new interface, so we are going to create a new interface named User Mirpur, right. And I'm going to create that inner mappers package. So I'll click on Finish. So first thing you store, I'm going to put the Mappa annotation and then caecum and shift over to import the package. So our abstract Mappa package got imported. So to satisfy the spring dependency injection. So I'm going to say component model. Is a cold spring, right, so that looks good. Let me save it. Now we are going to define two things. OK, so before defining them, we need to create our map, for instance. Okay, so user mapper, I will say this as it stands, is equal to map a start, get Mappa and use that map or dot class. Right. So now I have created our map, for instance, and I will create the two methods. So one method is for either a regular user object. OK. OK, so I'm doing to get service. Right. So which means like from user to user data so I can see. User to user data, and the second is a list of users, right? So a list of users to list of user data was right. My data on user enmasse. Did you vote? Yeah. So we need to do user to user data and then user to list of users to list of user. I must do. So let's do that now. Right. So let me create our first method that is so true. Tintype is going to be user data. All right. So we have the two method names defined here. You can see here. Right. So user to user data will. So I'll say user to user data. And so what are the parameters? Which means what is the input for this? We are going to provide the input as user and then output as user data input is going to be user. Right. And we can do any variable here, entity Y because user is entity. You can even say does entity also or you can see user, user, whatever, it is convenient for us. OK, so now we will also say it is user and mass data will always. I forget this. OK. OK, so that the naming convention will be good for us, OK? Yeah, so this is good. And then let me also introduce a package that looks good. So now we completed the. First one, so now the second method, so we are going to convert users to user data was so that's our method, right? So which means we need to get the return type list of user hamis data was faked, user did videos and the method will have. List of users right here, I can say it as entity or even the users, whatever I want to something, and then let us import the Java util list. So we have completed creating methods now. OK, so let me save these things, OK? So this completes our. Maps that map our interface creation, so we'll go back to our next step, which is step, right. So if you see step forward, we have created a user interface and it with a direct mapper and to satisfy the spring dependency injection. So we have also user component model and then added the spring there. OK, and then we have created two methods. One is user to use additive and the other is user to users dual. So user data was OK and we didn't add this for now currently. So we will add it later. So what happens? You will see and then add the mapping later, OK. So if you have multiple mappings, what we are going to do also we will see. OK, so that Fano will step Face-To-Face to create the list services by calling the method defined in the abstract map. So I'm going to create a new user map struct controller. Right. So let's go back. So you're. And we'll go to our comptrollers section. A new class and alsi username abstract controller. So first thing is to create it as it the controller and I will also say request mapping and I will say an abstract slash user's comment of total import, OK. So now we are going to define two methods here. My abstract controller. Before that, what we'll do is we'll operate our user repository, user repository. Right, and then there are two world coming on. All right, so the next year, we also need to upgrade our user interface, what we have created just now. Right. So we will also automate that right to what I mentioned to import. Right. So now finally, we have everything ready. So we need to create two methods. One is get all user details and then get all users by user. Right. So those two methods we will implement now. So let's start with creating the list of user slide. So we'll start with that for now. OK, so I'll set list and then user data will. So, as usual, I made a mistake. It is a user and must do so. My name is User and messaged you. OK, and then let me put both the things that. So, Joe, are you to list? And. Import that must do so, it'll get all user data was. Now we need to return the users, right? So let's start with the user mapper, Dot. OK, so we have the list of users returning. We have one method inside where users to user data will. Yes, OK, so I use that and the input should be a thorough list of users we need to bring and then send it to this respectful method. So I'll say. Use a repository, but find out. OK, well, we'll get me the list of users and that I am going to pass through the m'appelle interface and this will convert and then send it as a list of user names data was. So now this is going to be a request once we get mapping. And Comanche's, total important one, so, OK, so important. So let's go back to our postman and then test this right. So let me copy existing elsea new request and request and I will say get all users from abstract. Right. And let me minimize these things. So we are here, Getúlio, this abstract and our thing is localhost and we need to see a map struct slash uses map SWC is slash uses, that's all. So they use this method. Right. Let me see it and then send. OK, so we got the response successfully, which means our transformation worker. So it brought all the users and then sent with only user data username and then email address. Now what we need to do is if you see here, email addresses null because if you see in the. User, you have the email and in the user, unless you have the email address, so by default, implicitly, it doesn't matter because we have the difference in the names. So what we need to do now. So we need to go into our Mappa and then define the mappings. Right. So let me go to the Mirpur and we need to define the mappings in our entity. Right. So here, which is nothing. But if you define here, it will be applicable for Distel. So I will say a delayed mapping and we need to say target is. E-mail address, which is nothing, but I can even say email address I started and I can even say a source here, quote sources. A.M., right? Good, so sources e-mail and then target this email address and also let me put a mapping from our abstract. OK, so now I have computers or mapping sources called e-mail and then target to email address. Let me save it. OK, so let's go ahead and start Getúlio, this one more time, super. So we said Kennedy addressed to simplify dot com divide the reverse tax, simplify dot com b mark. We are getting all the email address for the three users which are present in our history database. So this completes our recreation of how you get all users matter using the device and then model Mappa. So one thing here is now you have one thing. You have mapped it. If you have multiple things, what we are going to do. Right. So let's also complete that before going to get usable ID to you. Right. So let me say that I have something here called OK, private string of. All right. So I'll say here, real name, but there it is rule. OK, so I'll say C so I'll regenerate this one. At least under the rules constructor. Right. Source and gingerbread constructor using fields. OK, so I have also out right now. So now I also attended the getters and setters for the real name, right. So gender getters and setters and for the real name, we are generating it generally. So now you have the name also added here. Right. So and then there it is. Rule. So let's go and test what happens. OK, so a name is coming null and we are going to define multiple things here. That's the important thing we are seeing in the user map. So what we need to do is we need to see it. Did it mappings? And let's open it. And. We will. Close it so we have to find one mapping. You've got to import the mappings from abstract. OK, now will they find one more mapping? Seeing source is equal to what is that? It is all right and the target is equal to fullName. And then see, so if you have multiple mappings, what we are going to do, we are seeing now. So let me see that we got that. All right. So that's all. 
